"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[478],{7164:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>a,toc:()=>d});var s=l(4848),t=l(8453);const c={title:"Eager and Lazy Cells",description:"Controlling the evaluation strategy of cells",sidebar_position:3},i="Eager and Lazy Cells",a={id:"advanced/eager-lazy-cells",title:"Eager and Lazy Cells",description:"Controlling the evaluation strategy of cells",source:"@site/docs/advanced/eager-lazy-cells.md",sourceDirName:"advanced",slug:"/advanced/eager-lazy-cells",permalink:"/docs/advanced/eager-lazy-cells",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Eager and Lazy Cells",description:"Controlling the evaluation strategy of cells",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Lightweight Computed Cells",permalink:"/docs/advanced/lightweight-cells"},next:{title:"ValueCell Subclass 1",permalink:"/docs/advanced/writing-cells-1"}},o={},d=[{value:"Eager cells",id:"eager-cells",level:2},{value:"Store and mutable computed cells",id:"store-and-mutable-computed-cells",level:2},{value:"When to use changesOnly?",id:"when-to-use-changesonly",level:2}];function r(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"eager-and-lazy-cells",children:"Eager and Lazy Cells"}),"\n",(0,s.jsxs)(n.p,{children:["Stateful computed cells, created with ",(0,s.jsx)(n.code,{children:"ValueCell.computed"})," are lazy by\ndefault. This means the value of the cell is only computed, if it is\nactually referenced. If the value of a computed is never referenced,\nit is never computed, even if the computed cell is being observed."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsx)(n.p,{children:"The value of a lazy computed cell is cached until its argument cells\nchange, but its not computed until it is referenced for the first\ntime."})}),"\n",(0,s.jsx)(n.h2,{id:"eager-cells",children:"Eager cells"}),"\n",(0,s.jsx)(n.p,{children:"An eager computed cell always recomputes its value when its argument\ncells change. The following cells, for example, are eager:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Previous value cells (created with ",(0,s.jsx)(n.code,{children:".previous"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Asynchronous cells (created with ",(0,s.jsx)(n.code,{children:".wait"}),", ",(0,s.jsx)(n.code,{children:".waitLast"}),", ",(0,s.jsx)(n.code,{children:".awaited"}),")"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A computed cell can be made eager by providing a value of ",(0,s.jsx)(n.code,{children:"true"})," to\nthe ",(0,s.jsx)(n.code,{children:"changesOnly"})," argument of ",(0,s.jsx)(n.code,{children:"ValueCell.computed"}),". This also changes\nthe behaviour of the cell, such that it only notifies its observers\nof changes to its value, only if the value has actually changed."]}),"\n",(0,s.jsx)(n.p,{children:"Example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final a = MutableCell(0);\n\nfinal isEven = ValueCell.computed(() => a().isEven,\n    changesOnly: true\n);\n\nfinal watch = ValueCell.watch(() {\n    print('${a.peek()}.isEven: ${isEven()}')\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example a cell ",(0,s.jsx)(n.code,{children:"isEven"})," is defined which is equal to ",(0,s.jsx)(n.code,{children:"true"}),"\nwhen the value of ",(0,s.jsx)(n.code,{children:"a"})," is an even number and equal to ",(0,s.jsx)(n.code,{children:"false"})," when the\nvalue of ",(0,s.jsx)(n.code,{children:"a"})," is an odd number."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["A watch function is defined that prints the value of ",(0,s.jsx)(n.code,{children:"isEven"})," to the\nconsole. The watch function is only called when ",(0,s.jsx)(n.code,{children:"isEven"})," notifies its\nobservers, since ",(0,s.jsx)(n.code,{children:"a"})," is only observed via ",(0,s.jsx)(n.code,{children:"a.peek"}),"."]})}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"changesOnly"})," is ",(0,s.jsx)(n.code,{children:"true"})," the following code:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"a.value = 1;\na.value = 2;\na.value = 4;\na.value = 6;\na.value = 8;\na.value = 10;\na.value = 11;\n"})}),"\n",(0,s.jsx)(n.p,{children:"results in the following being printed to the console:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"1.isEven: false\n2.isEven: true\n11.isEven: false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice the watch function was not called when the values ",(0,s.jsx)(n.code,{children:"4"}),", ",(0,s.jsx)(n.code,{children:"6"}),", ",(0,s.jsx)(n.code,{children:"8"}),"\nand ",(0,s.jsx)(n.code,{children:"10"})," were assigned to ",(0,s.jsx)(n.code,{children:"a"}),". This is because the value of ",(0,s.jsx)(n.code,{children:"isEven"}),"\ndid not change with those assignments."]}),"\n",(0,s.jsxs)(n.p,{children:["If ",(0,s.jsx)(n.code,{children:"changesOnly"})," is ",(0,s.jsx)(n.code,{children:"false"}),", which is the default if ",(0,s.jsx)(n.code,{children:"changesOnly"})," is\nomitted, the following is printed to the console:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"1.isEven: false\n2.isEven: true\n4.isEven: true\n6.isEven: true\n8.isEven: true\n10.isEven: true\n11.isEven: false\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice that the watch function is now called even if the value of\n",(0,s.jsx)(n.code,{children:"isEven"})," did not change. This is because the value of ",(0,s.jsx)(n.code,{children:"a"}),", which is a\ndependency of ",(0,s.jsx)(n.code,{children:"isEven"})," and hence causes the value of ",(0,s.jsx)(n.code,{children:"isEven"})," to be\nrecomputed. Since ",(0,s.jsx)(n.code,{children:"changesOnly"})," is ",(0,s.jsx)(n.code,{children:"false"}),", ",(0,s.jsx)(n.code,{children:"isEven"})," does not check\nwhether the newly computed value is equal to the previous value."]}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"changesOnly: true"})," can be used to ensure that the value of a cell is\nalways updated even when its value is not referenced. This is useful to\navoid the pitfall with ",(0,s.jsx)(n.code,{children:"ValueCell.none"})," mentioned in ",(0,s.jsx)(n.a,{href:"/docs/basics/cell-expressions#aborting-a-computation",children:"Aborting a\ncomputation"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"store-and-mutable-computed-cells",children:"Store and mutable computed cells"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"changesOnly"})," argument is accepted by the ",(0,s.jsx)(n.code,{children:".store()"}),", which\ncreates a cell that caches the value of another cell. This can be used\nto convert any cell to an eager cell, even if you don't have access to\nthe constructor of the cell."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"isEven"})," cell from the previous example can also be defined with\nthe following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final isEven = a.apply((a) => a.isEven)\n    .store(changesOnly: true);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"changesOnly"})," argument is also accepted by\n",(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/MutableCell/MutableCell.computed.html",children:(0,s.jsx)(n.code,{children:"MutableCell.computed"})}),"\nand\n",(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ComputeExtension/mutableApply.html",children:(0,s.jsx)(n.code,{children:".mutableApply"})}),". This\nalso works if a ",(0,s.jsx)(n.code,{children:"key"})," argument is provided to ",(0,s.jsx)(n.code,{children:"mutableApply"}),", which if\nyou recall, creates a mutable stateless computed cell."]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-changesonly",children:"When to use changesOnly?"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"changesOnly: true"})," should be used either to prevent computation and\nwatch functions from being called unnecessarily or to convert a\ncomputed cell from its default lazy semantics to eager semantics. This\nis particularly useful in conjunction with ",(0,s.jsx)(n.code,{children:"ValueCell.none"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["It should be noted that ",(0,s.jsx)(n.code,{children:"changesOnly: true"})," (or an equivalent) is\nalready used in the following cells thus there is no need to add\n",(0,s.jsx)(n.code,{children:".store(changesOnly: true)"})," to them:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Cell extensions for properties of ",(0,s.jsx)(n.a,{href:"http://localhost:3000/docs/basics/user-defined-types",children:"user defined\ntypes"})]}),"\n",(0,s.jsx)(n.li,{children:"Previous value cells"}),"\n",(0,s.jsx)(n.li,{children:"Extension properties for cells holding lists, maps and sets."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>i,x:()=>a});var s=l(6540);const t={},c=s.createContext(t);function i(e){const n=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(c.Provider,{value:n},e.children)}}}]);