"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[216],{6002:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>a});var s=l(4848),i=l(8453);const t={title:"Cell Keys",description:"What cell keys are and what they are used for.",sidebar_position:1},c="Cell Keys",r={id:"advanced/cell-keys",title:"Cell Keys",description:"What cell keys are and what they are used for.",source:"@site/docs/advanced/cell-keys.md",sourceDirName:"advanced",slug:"/advanced/cell-keys",permalink:"/live_cells/docs/advanced/cell-keys",draft:!1,unlisted:!1,editUrl:"https://github.com/alex-gutev/live_cells/docs/advanced/cell-keys.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Cell Keys",description:"What cell keys are and what they are used for.",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Advanced",permalink:"/live_cells/docs/category/advanced"}},d={},a=[{value:"Keyed cells",id:"keyed-cells",level:2},{value:"Which cells have keys?",id:"which-cells-have-keys",level:2},{value:"Keys for your own cells",id:"keys-for-your-own-cells",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"cell-keys",children:"Cell Keys"}),"\n",(0,s.jsx)(n.p,{children:"We stated a couple of times in the documentation that a certain\nproperty returns a keyed cell. Now we'll explain what that actually\nmeans."}),"\n",(0,s.jsx)(n.h2,{id:"keyed-cells",children:"Keyed cells"}),"\n",(0,s.jsxs)(n.p,{children:["A keyed cell is a cell with a key that identifies the cell. If two\ndistinct ",(0,s.jsx)(n.code,{children:"ValueCell"})," instances have the same key, under ",(0,s.jsx)(n.code,{children:"=="}),", then the\ntwo cells compare ",(0,s.jsx)(n.code,{children:"=="}),". In-effect, this allows them to function as\nthough they are the same cell despite being two separate objects."]}),"\n",(0,s.jsxs)(n.p,{children:["Great, so how's that useful? Consider the following code which creates\na ",(0,s.jsx)(n.code,{children:"CellWidget"})," that observes a cell ",(0,s.jsx)(n.code,{children:"a"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((_) {\n    final a = ...;\n    \n    return Text(a());\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"a"})," is created in the widget build function, and observed by the\n",(0,s.jsx)(n.code,{children:"CellWidget"}),". When the ",(0,s.jsx)(n.code,{children:"CellWidget"})," is rebuilt, the build function is\ncalled again, a new ",(0,s.jsx)(n.code,{children:"a"})," is created and the ",(0,s.jsx)(n.code,{children:"CellWidget"})," is now\nobserving the new ",(0,s.jsx)(n.code,{children:"a"})," alongside the previous ",(0,s.jsx)(n.code,{children:"a"}),". With every rebuild\nof the ",(0,s.jsx)(n.code,{children:"CellWidget"}),", a new ",(0,s.jsx)(n.code,{children:"a"})," is being observed. Besides leaking\nmemory, the state of ",(0,s.jsx)(n.code,{children:"a"})," is lost and reset on every build."]}),"\n",(0,s.jsxs)(n.p,{children:["Cell keys were created to avoid this problem. If the ",(0,s.jsx)(n.code,{children:"CellWidget"})," is\nrebuilt and a new ",(0,s.jsx)(n.code,{children:"a"})," is created, BUT with the same key as the\nprevious ",(0,s.jsx)(n.code,{children:"a"}),", the ",(0,s.jsx)(n.code,{children:"CellWidget"})," sees it as the same cell and continues\nobserving the previous ",(0,s.jsx)(n.code,{children:"a"}),". More importantly, the new ",(0,s.jsx)(n.code,{children:"a"})," shares the\nsame state (and hence the same value) as the previous ",(0,s.jsx)(n.code,{children:"a"}),". In-effect\nis the same cell, just referenced by a different object."]}),"\n",(0,s.jsxs)(n.p,{children:["Previously, we said cells should be created in a ",(0,s.jsx)(n.code,{children:"CellWidget"})," with\n",(0,s.jsx)(n.code,{children:"context.cell"}),". So why the need for keys? Keys, are especially useful\nfor extension properties which return cells. They allow you to write\nthe following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((c) => {\n    final l = c.cell(() => MutableCell([1, 2, 3]));\n    final a = l.first;\n    \n    return Text('${a()}');\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"instead of:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((c) => {\n    final l = c.cell(() => MutableCell([1, 2, 3]));\n    final a = c.cell(() => l.first);\n    \n    return Text('${a()}');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Spot the difference? We didn't wrap ",(0,s.jsx)(n.code,{children:"l.first"})," in ",(0,s.jsx)(n.code,{children:"cell(...)"})," in the\nfirst example. We don't have to because the ",(0,s.jsx)(n.code,{children:"first"})," property returns a\nkeyed cell so in-effect it will always return the same cell, given\nthat the property getter is called on the same cell. The first code\nsnippet is much simpler, more intuitive and more readable than the\nsecond snippet."]}),"\n",(0,s.jsxs)(n.p,{children:["Keys are not only useful in cell widgets, but are useful wherever a\ncell property, which itself returns a cell, is accessed. This is\nallows you to freely reference cell extension properties such as\n",(0,s.jsx)(n.code,{children:".first"}),", as many times as you need to without having to store the\nreturned cell in a local variable first."]}),"\n",(0,s.jsx)(n.h2,{id:"which-cells-have-keys",children:"Which cells have keys?"}),"\n",(0,s.jsx)(n.p,{children:"The cells returned by cell property getters are always keyed\ncells. This includes (but is not limited to):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"List cell extension properties:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".first"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".last"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".length"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Map cell extension properties"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"previous"})," cells"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"peek"})," cells"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Cell property accessors generated for classes annotated with\n",(0,s.jsx)(n.code,{children:"@CellExtension"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Also the following cells are keyed:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Constant cells"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Cells returned by the indexing operator on List and Map cells:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"list[1.cell]"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"map['key'.cell]"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Equality comparison cells created with ",(0,s.jsx)(n.code,{children:"eq"})," and ",(0,s.jsx)(n.code,{children:"neq"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["To be sure whether a specific method returns a keyed cell or not,\nconsult the ",(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/",children:"API\nReference"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"keys-for-your-own-cells",children:"Keys for your own cells"}),"\n",(0,s.jsxs)(n.p,{children:["You can assign a key to your own computed cells, created with\n",(0,s.jsx)(n.code,{children:"ValueCell.computed"}),", by providing the key in the ",(0,s.jsx)(n.code,{children:"key"})," argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="Keyed computed cell"',children:"final cell = ValueCell.computed(() => a() + b(),\n    key: MyKey(a, b)\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Any object which overloads ",(0,s.jsx)(n.code,{children:"=="})," and ",(0,s.jsx)(n.code,{children:"hashCode"})," can serve as a cell\nkey. For your own keys, you're generally encouraged to do the following:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use a class per key type. For example if you have a function which\nreturns a cell, create a key class that is only used by that\nfunction."}),"\n",(0,s.jsxs)(n.li,{children:["If your cell depends on other cells, include those cells in the key\nclass and in its implementation of ",(0,s.jsx)(n.code,{children:"=="}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An example implementation of ",(0,s.jsx)(n.code,{children:"MyKey"})," from the example above:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="Example key implementation"',children:"class MyKey {\n    final ValueCell a;\n    final ValueCell b;\n    \n    MyKey(this.a, this.b);\n    \n    @override\n    bool operator ==(other) => other is MyKey &&\n        a == other.a &&\n        b == other.b;\n        \n    @override\n    int get hashCode => Object.hash(runtimeType, a, b);     \n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsx)(n.p,{children:"Mutable cells, with the exception of lightweight mutable computed\ncells, cannot be assigned a key."})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>c,x:()=>r});var s=l(6540);const i={},t=s.createContext(i);function c(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);