"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[960],{6986:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>d,metadata:()=>c,toc:()=>a});var l=i(4848),t=i(8453);const d={title:"Cells in Widgets",description:"Using cells in widgets",sidebar_position:2},s="Cells in Widgets",c={id:"basics/cell-widgets",title:"Cells in Widgets",description:"Using cells in widgets",source:"@site/docs/basics/cell-widgets.md",sourceDirName:"basics",slug:"/basics/cell-widgets",permalink:"/docs/basics/cell-widgets",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Cells in Widgets",description:"Using cells in widgets",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Cells",permalink:"/docs/basics/cells"},next:{title:"Cell Expressions",permalink:"/docs/basics/cell-expressions"}},o={},a=[{value:"Defining cells directly in the build method",id:"defining-cells-directly-in-the-build-method",level:2},{value:"Watching cells in widgets",id:"watching-cells-in-widgets",level:2},{value:"Subclassing CellWidget",id:"subclassing-cellwidget",level:2}];function r(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h1,{id:"cells-in-widgets",children:"Cells in Widgets"}),"\n",(0,l.jsxs)(n.p,{children:["The simplest way to use the value of a cell in a widget is with\n",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),", which creates a widget that observes one or more\ncells. Whenever the values of the observed cells change, the widget is\nrebuilt."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="CellWidget.builder"',children:"CellWidget.builder((context) => Text('Count: ${count()}'));\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The example above creates a widget that observes the value of a\n",(0,l.jsx)(n.code,{children:"count"})," cell and displays it in a ",(0,l.jsx)(n.code,{children:"Text"})," widget. Whenever the value of\n",(0,l.jsx)(n.code,{children:"count"})," changes, the widget is rebuilt."]}),"\n",(0,l.jsx)(n.p,{children:"Let's put this together to build a simple counter:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Counter using cells"',children:"class Counter extends StatefulWidget {\n    @override\n    State<Counter> createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n    final count = MutableCell(0);\n\n    @override\n    Widget build(BuildContext context) => FilledButton(\n        child: CellWidget.builder((_) => Text('${count()}')),\n        onPressed: () => count.value++\n    );\n}\n"})}),"\n",(0,l.jsx)(n.p,{children:"The example above:"}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Defines a button which increments a ",(0,l.jsx)(n.code,{children:"count"})," cell when pressed."]}),"\n",(0,l.jsxs)(n.li,{children:["The value of the ",(0,l.jsx)(n.code,{children:"count"})," cell is displayed in the child of the\n",(0,l.jsx)(n.code,{children:"FilledButton"})," using ",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),"."]}),"\n",(0,l.jsx)(n.li,{children:"Pressing the button results in the widget being rebuilt and hence\nthe new counter value being displayed."}),"\n"]}),"\n",(0,l.jsx)(n.admonition,{type:"info",children:(0,l.jsxs)(n.p,{children:["Unlike ",(0,l.jsx)(n.code,{children:"ValueNotifier"})," and ",(0,l.jsx)(n.code,{children:"ChangeNotifier"})," you don't have to call\n",(0,l.jsx)(n.code,{children:"dispose"})," on cells."]})}),"\n",(0,l.jsx)(n.h2,{id:"defining-cells-directly-in-the-build-method",children:"Defining cells directly in the build method"}),"\n",(0,l.jsxs)(n.p,{children:["In the previous section the ",(0,l.jsx)(n.code,{children:"count"})," cell, which holds the value of the\ncounter, is stored in the ",(0,l.jsx)(n.code,{children:"State"})," class of a ",(0,l.jsx)(n.code,{children:"StatefulWidget"}),". This is\na good starting point, but it will quickly get tiring if you need to\ndefine cells that depend on other cells also defined in the same\n",(0,l.jsx)(n.code,{children:"State"})," class."]}),"\n",(0,l.jsxs)(n.p,{children:["Cells can be defined directly in the build function of a\n",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),". The state of the cells that are defined in the\nbuild function is persisted between builds of the widget. This is very\nconvenient for cells which manage state that is local to a widget."]}),"\n",(0,l.jsxs)(n.p,{children:["Using ",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),", the counter can be implemented as follows:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Defining cells directly in CellWidget.builder"',children:"CellWidget.builder((context) {\n    final count = MutableCell(0);\n\n    return FilledButton(\n        child: Text('${count()}'),\n        onPressed: () => count.value++\n    );\n});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"count"})," cell is defined directly in the build function provided to\n",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),". This is functionally equivalent to the\nimplementation using ",(0,l.jsx)(n.code,{children:"StatefulWidget"}),", however much more succinct."]}),"\n",(0,l.jsx)(n.p,{children:"More than one cell can be defined in the build function:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Multiple cells defined in CellWidget.builder"',children:"CellWidget.builder((context) {\n    final count1 = MutableCell(0);\n    final count2 = MutableCell(0);\n\n    return Column(\n        children: [\n            FilledButton(\n                child: Text('${count1()}'),\n                onPressed: () => count1.value++\n            ),\n            FilledButton(\n                child: Text('${count2()}'),\n                onPressed: () => count2.value++\n            )\n        ]\n    );\n});\n"})}),"\n",(0,l.jsx)(n.p,{children:"In the example above, two separate cells are defined in a single build\nfunction, each representing a different counter."}),"\n",(0,l.jsxs)(n.admonition,{type:"warning",children:[(0,l.jsx)(n.mdxAdmonitionTitle,{}),(0,l.jsxs)(n.p,{children:["When defining cells directly within ",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),",\nthe definitions should not be placed in:"]}),(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsx)(n.li,{children:"Conditionals"}),"\n",(0,l.jsx)(n.li,{children:"Loops"}),"\n",(0,l.jsxs)(n.li,{children:["Callback and builder functions of widgets nested within the ",(0,l.jsx)(n.code,{children:"CellWidget"}),"."]}),"\n"]})]}),"\n",(0,l.jsxs)(n.admonition,{title:"Examples of good definitions",type:"tip",children:[(0,l.jsxs)(n.p,{children:["The following cell definitions within ",(0,l.jsx)(n.code,{children:"CellWidget.builder"})," are good:"]}),(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((_) {\n    final a = MutableCell(0);\n    final b = MutableCell(1);\n    ...\n});\n"})})]}),"\n",(0,l.jsxs)(n.admonition,{title:"Examples of badly placed definitions",type:"danger",children:[(0,l.jsxs)(n.p,{children:["The following are examples of badly placed cell definitions in\n",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),". Don't do the following:"]}),(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((_) {\n    if (...) {\n        // Bad because the cell is defined\n        // conditionally\n        final a = MutableCell(0);\n    }\n    \n    while (...) {\n        // Bad because the definition appears\n        // within a loop\n        final b = MutableCell(1);\n    }\n    \n    return Builder((_) {\n        // Bad because the definition is no longer in\n        // the build function provided to CellWidget.builder,\n        // but in a nested widget builder function.\n        final c = MutableCell(2);\n        ...\n    });\n});\n"})}),(0,l.jsxs)(n.p,{children:["If you end up doing something similar to the above, ",(0,l.jsx)(n.code,{children:"CellWidget"})," will\nnot be able to persist the state of the cells between builds."]})]}),"\n",(0,l.jsx)(n.h2,{id:"watching-cells-in-widgets",children:"Watching cells in widgets"}),"\n",(0,l.jsxs)(n.p,{children:["Like cells, watch functions can be defined, using ",(0,l.jsx)(n.code,{children:"ValueCell.watch"})," or\n",(0,l.jsx)(n.code,{children:"Watch"}),", directly in the build function of a ",(0,l.jsx)(n.code,{children:"CellWidget"}),". The watch\nfunction is registered on the first build of the widget, and is\nautomatically stopped when the widget is unmounted."]}),"\n",(0,l.jsx)(n.admonition,{type:"note",children:(0,l.jsx)(n.p,{children:"The watch function is called once when it is registered during the\nfirst build of the widget. Rebuilding the widget does not cause the\nwatch function to be called again."})}),"\n",(0,l.jsx)(n.admonition,{type:"caution",children:(0,l.jsxs)(n.p,{children:["The same rules apply to the placement of watch function definitions,\nthat apply to the placement of cell definitions within\n",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),"."]})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Watch function in widget"',children:"CellWidget.builder((context) {\n    final count = MutableCell(0);\n\n    ValueCell.watch(() => print('Count ${count()}'));\n\n    return FilledButton(\n        child: Text('${count()}'),\n        onPressed: () => count.value++\n    );\n});\n"})}),"\n",(0,l.jsx)(n.h2,{id:"subclassing-cellwidget",children:"Subclassing CellWidget"}),"\n",(0,l.jsxs)(n.p,{children:["We'll be using ",(0,l.jsx)(n.code,{children:"CellWidget.builder"})," throughout the documentation,\nsince its succinct and convenient. However, if you want to make a\nwidget which will be used in more than one place, you should subclass\n",(0,l.jsx)(n.code,{children:"CellWidget"})," instead."]}),"\n",(0,l.jsxs)(n.p,{children:["A ",(0,l.jsx)(n.code,{children:"CellWidget"})," subclass can observe and define cells, and watch\nfunctions, in the ",(0,l.jsx)(n.code,{children:"build"})," method, just like ",(0,l.jsx)(n.code,{children:"CellWidget.builder"}),":"]}),"\n",(0,l.jsxs)(n.p,{children:["The counter example using a ",(0,l.jsx)(n.code,{children:"CellWidget"})," subclass:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="CellWidget subclass"',children:"class Counter extends CellWidget {\n    @override\n    Widget build(BuildContext context) {\n        final count = MutableCell(0);\n\n        ValueCell.watch(() => print('Count: ${count()}'));\n\n        return FilledButton(\n            child: Text('${count()}'),\n            onPressed: () => count.value++\n        );\n    }\n}\n"})}),"\n",(0,l.jsx)(n.admonition,{type:"note",children:(0,l.jsxs)(n.p,{children:["The magic that allows you to define cells directly within\n",(0,l.jsx)(n.code,{children:"CellWidget.builder"})," works by assigning a numerically indexed key to\neach cell that is defined within the build function/method. That's why\nyou should avoid placing definitions within loops and\nconditionals. Cell keys will be covered in the advanced section of the\ndocumentation but if you're curious you can skip ahead to ",(0,l.jsx)(n.a,{href:"/docs/advanced/cell-keys",children:"Cell\nKeys"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(r,{...e})}):r(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var l=i(6540);const t={},d=l.createContext(t);function s(e){const n=l.useContext(d);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),l.createElement(d.Provider,{value:n},e.children)}}}]);