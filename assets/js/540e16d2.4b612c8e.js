"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[414],{8e3:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>a,contentTitle:()=>s,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>o});var i=l(4848),t=l(8453);const c={title:"Self Cells",description:"A cell which can access its own value",sidebar_position:14},s="Self Cells",r={id:"basics/self-cells",title:"Self Cells",description:"A cell which can access its own value",source:"@site/docs/basics/self-cells.md",sourceDirName:"basics",slug:"/basics/self-cells",permalink:"/docs/basics/self-cells",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:14,frontMatter:{title:"Self Cells",description:"A cell which can access its own value",sidebar_position:14},sidebar:"tutorialSidebar",previous:{title:"Effect Cells",permalink:"/docs/basics/effect-cells"},next:{title:"Advanced",permalink:"/docs/category/advanced"}},a={},o=[{value:"Defining Self Cells",id:"defining-self-cells",level:2},{value:"Defining Operations on State",id:"defining-operations-on-state",level:2},{value:"Pitfalls:",id:"pitfalls",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"self-cells",children:"Self Cells"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.em,{children:"self cell"})," is a computed cell that can access its own value within\nits value computation function."]}),"\n",(0,i.jsx)(n.h2,{id:"defining-self-cells",children:"Defining Self Cells"}),"\n",(0,i.jsxs)(n.p,{children:["Self cells are created with the\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/SelfCell-class.html",children:"SelfCell"}),"\nconstructor, which takes the value computation function just like\n",(0,i.jsx)(n.code,{children:"ValueCell.computed"}),". However, unlike ",(0,i.jsx)(n.code,{children:"ValueCell.computed"}),", the\nvalue computation function is passed a ",(0,i.jsx)(n.code,{children:"self"})," argument. The ",(0,i.jsx)(n.code,{children:"self"}),"\nargument is a function which when called returns the current value of\nthe cell."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Self Cell Example"',children:"final increment = ActionCell();\n\nfinal count = SelfCell((self) {\n    increment.observe();\n    return self() + 1;\n}, initialValue: 0);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above a self cell ",(0,i.jsx)(n.code,{children:"count"})," is defined which observes an\naction cell, ",(0,i.jsx)(n.code,{children:"increment"}),". The value of the ",(0,i.jsx)(n.code,{children:"count"})," cell is one plus\nits previous value, and it is updated whenever the ",(0,i.jsx)(n.code,{children:"increment"})," action\ncell is triggered."]}),"\n",(0,i.jsxs)(n.p,{children:["Note the ",(0,i.jsx)(n.code,{children:"initialValue"})," argument, which takes the initial value to be\nreturned by ",(0,i.jsx)(n.code,{children:"self"}),", in this case ",(0,i.jsx)(n.code,{children:"0"}),". ",(0,i.jsx)(n.code,{children:"initialValue"})," can be omitted in\nwhich case, the first call to ",(0,i.jsx)(n.code,{children:"self"})," results in\n",(0,i.jsx)(n.code,{children:"UninitializedCellError"})," being thrown."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"initialValue"})," is omitted, the value type of the self cell can no\nlonger be deduced and thus has to be specified manually,\ne.g. ",(0,i.jsx)(n.code,{children:"SelfCell<int>(...)"}),"."]})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"\nValueCell.watch(() {\n    print('${count()}');\n}); // Prints 1\n\nincrement.trigger(); // Prints 2\nincrement.trigger(); // Prints 3\n\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"self"})," argument is a function which returns the value, rather than\nbeing the value itself. The reason for this is that the value of the\nself cell can be an exception. In this case calling ",(0,i.jsx)(n.code,{children:"self"})," rethrows\nthe exception."]})}),"\n",(0,i.jsx)(n.h2,{id:"defining-operations-on-state",children:"Defining Operations on State"}),"\n",(0,i.jsxs)(n.p,{children:["Combined with action cell chaining, which we saw in ",(0,i.jsx)(n.a,{href:"action-cells",children:"Action\nCells"}),", we can use different logic for updating the self\ncell's value, depending on which action cell was triggered:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final recompute = ActionCell();\nfinal delta = MutableCell(1);\n\nfinal increment = recompute.chain(() {\n    MutableCell.batch(() {\n      recompute.trigger();\n      delta.value = 1;\n    });\n});\n\nfinal decrement = recompute.chain(() {\n    MutableCell.batch(() {\n      recompute.trigger();\n      delta.value = -1;\n    });\n});\n\nfinal count = SelfCell((self) {\n    recompute.observe();\n    return self() + delta();\n}, initialValue: 0);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In this example the value of the ",(0,i.jsx)(n.code,{children:"count"})," cell is incremented when the\n",(0,i.jsx)(n.code,{children:"increment"})," action cell is triggered, and decremented when the\n",(0,i.jsx)(n.code,{children:"decrement"})," action cell is triggered."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"ValueCell.watch(() {\n    print('${count()}');\n}); // Prints 1;\n\nincrement.trigger(); // Prints: 2\nincrement.trigger(); // Prints: 3\n\ndecrement.trigger(); // Prints: 2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This is achieved by defining ",(0,i.jsx)(n.code,{children:"increment"})," and ",(0,i.jsx)(n.code,{children:"decrement"})," as chained\naction cells, which trigger the ",(0,i.jsx)(n.code,{children:"recompute"})," cell and set the value of\n",(0,i.jsx)(n.code,{children:"delta"})," to ",(0,i.jsx)(n.code,{children:"1"})," and ",(0,i.jsx)(n.code,{children:"-1"}),", respectively. It is necessary to trigger the\n",(0,i.jsx)(n.code,{children:"recompute"})," cell, because assigning ",(0,i.jsx)(n.code,{children:"1"})," to ",(0,i.jsx)(n.code,{children:"delta"})," while its value is\nalready ",(0,i.jsx)(n.code,{children:"1"})," will not cause ",(0,i.jsx)(n.code,{children:"count"})," to be recomputed. The same applies\nwhen assigning ",(0,i.jsx)(n.code,{children:"-1"})," to ",(0,i.jsx)(n.code,{children:"delta"})," while its value is already ",(0,i.jsx)(n.code,{children:"-1"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:['This allows you to define a set of "operations" on the state of a self\ncell. For example, this definition of ',(0,i.jsx)(n.code,{children:"count"})," can be packaged in a\nfactory function, which exposes the ",(0,i.jsx)(n.code,{children:"count"}),", ",(0,i.jsx)(n.code,{children:"increment"})," and\n",(0,i.jsx)(n.code,{children:"decrement"})," cells:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"(ValueCell<int>, ActionCell, ActionCell) counter() {\n    // Definition from previous example\n    ...\n    return (count, increment, decrement)\n};\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or you can opt for a more structured approach such as the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"@immutable\nclass Counter {\n    final ValueCell<int> count;\n    final ActionCell increment;\n    final ActionCell decrement;\n    \n    factory Counter() {\n        // Definition from previous example\n        ...\n        return Counter._internal(\n            count: count,\n            increment: increment,\n            decrement: decrement\n        );\n    }\n    \n    const Counter._internal({\n        required this.count,\n        required this.increment,\n        required this.decrement\n    });\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This allows users of our newly packaged counter, to observe and modify\nthe counter's state, but does not allow the users to directly modify\nthe value of ",(0,i.jsx)(n.code,{children:"delta"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final counter = Counter();\n\nValueCell.watch(() {\n    print('${counter.count()}');\n}); // Prints: 1\n\ncounter.increment.trigger(); // Prints 2\ncounter.decrement.trigger(); // Prints 1\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["You can store any value in a ",(0,i.jsx)(n.code,{children:"SelfCell"}),", even instances of your own\nclasses."]})}),"\n",(0,i.jsx)(n.h2,{id:"pitfalls",children:"Pitfalls:"}),"\n",(0,i.jsx)(n.p,{children:"Be aware of the following pitfalls when using self cells:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Self cells need at least one observer to function correctly,\notherwise they will not have a state where they can keep track of\ntheir own value."}),"\n",(0,i.jsxs)(n.li,{children:["Once a self cell is disposed, when its last observer is removed, the\nvalue returned by ",(0,i.jsx)(n.code,{children:"self"})," is reset to the value provided in\n",(0,i.jsx)(n.code,{children:"initialValue"}),"."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>s,x:()=>r});var i=l(6540);const t={},c=i.createContext(t);function s(e){const n=i.useContext(c);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(c.Provider,{value:n},e.children)}}}]);