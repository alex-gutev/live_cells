"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[960],{6986:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>d,metadata:()=>c,toc:()=>a});var t=i(4848),l=i(8453);const d={title:"Cells in Widgets",description:"Using cells in widgets",sidebar_position:2},s="Cells in Widgets",c={id:"basics/cell-widgets",title:"Cells in Widgets",description:"Using cells in widgets",source:"@site/docs/basics/cell-widgets.md",sourceDirName:"basics",slug:"/basics/cell-widgets",permalink:"/docs/basics/cell-widgets",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Cells in Widgets",description:"Using cells in widgets",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Cells",permalink:"/docs/basics/cells"},next:{title:"Cell Expressions",permalink:"/docs/basics/cell-expressions"}},o={},a=[{value:"Defining cells directly in the build method",id:"defining-cells-directly-in-the-build-method",level:2},{value:"Watching cells in widgets",id:"watching-cells-in-widgets",level:2},{value:"Subclassing CellWidget",id:"subclassing-cellwidget",level:2}];function r(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"cells-in-widgets",children:"Cells in Widgets"}),"\n",(0,t.jsx)(n.p,{children:"Cells would be pretty boring if you could not use them in widgets."}),"\n",(0,t.jsxs)(n.p,{children:["The simplest way to use the value of a cell in a widget is with\n",(0,t.jsx)(n.code,{children:"CellWidget.builder"}),", which creates a widget that observes one or more\ncells. Whenever the values of the observed cells change, the widget is\nrebuilt."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="CellWidget.builder"',children:"CellWidget.builder((context) => Text('Count: ${count()}'));\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The example above creates a widget that observes the value of a\n",(0,t.jsx)(n.code,{children:"count"})," cell and displays it in a ",(0,t.jsx)(n.code,{children:"Text"})," widget. Whenever the value of\n",(0,t.jsx)(n.code,{children:"count"})," changes, the widget is rebuilt."]}),"\n",(0,t.jsx)(n.p,{children:"Let's put this together to build a simple counter:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Counter using cells"',children:"class Counter extends StatefulWidget {\n    @override\n    State<Counter> createState() => _CounterState();\n}\n\nclass _CounterState extends State<Counter> {\n    final count = MutableCell(0);\n\n    @override\n    Widget build(BuildContext context) => ElevatedButton(\n        child: CellWidget.Builder((_) => Text('${count()}')),\n        onPressed: () => count.value++\n    );\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"The example above:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Defines a button which increments a ",(0,t.jsx)(n.code,{children:"count"})," cell when pressed."]}),"\n",(0,t.jsxs)(n.li,{children:["The value of the ",(0,t.jsx)(n.code,{children:"count"})," cell is displayed in the child of the\n",(0,t.jsx)(n.code,{children:"ElevatedButton"})," using ",(0,t.jsx)(n.code,{children:"CellWidget.Builder"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Pressing the button results in the widget being rebuilt and hence\nthe new counter value being displayed."}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["Unlike ",(0,t.jsx)(n.code,{children:"ValueNotifier"})," and ",(0,t.jsx)(n.code,{children:"ChangeNotifier"})," you don't have to call\n",(0,t.jsx)(n.code,{children:"dispose"})," on cells."]})}),"\n",(0,t.jsx)(n.h2,{id:"defining-cells-directly-in-the-build-method",children:"Defining cells directly in the build method"}),"\n",(0,t.jsxs)(n.p,{children:["In the previous section the ",(0,t.jsx)(n.code,{children:"count"})," cell, which holds the value of the\ncounter, is stored in the ",(0,t.jsx)(n.code,{children:"State"})," class of a ",(0,t.jsx)(n.code,{children:"StatefulWidget"}),". This is\na good starting point, but it will quickly get tiring if you need to\ndefine cells that depend on other cells also defined in the same\n",(0,t.jsx)(n.code,{children:"State"})," class. Besides that having to use a ",(0,t.jsx)(n.code,{children:"StatefulWidget"})," just to\ndefine a cell is verbose and annoying."]}),"\n",(0,t.jsxs)(n.p,{children:["Luckily you can define cells directly in the build function of a\n",(0,t.jsx)(n.code,{children:"CellWidget.builder"}),". ",(0,t.jsx)(n.code,{children:"CellWidget"})," keeps track of the cells that were\ndefined in the build function and persists their state between builds\nof the widget, so you don't have to use a ",(0,t.jsx)(n.code,{children:"StatefulWidget"}),". This is\nvery convenient for cells which manage state that is local to a\nwidget."]}),"\n",(0,t.jsxs)(n.p,{children:["Using ",(0,t.jsx)(n.code,{children:"CellWidget.builder"}),", the counter can be implemented as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Defining cells directly in CellWidget.builder"',children:"CellWidget.builder((context) {\n    final count = MutableCell(0);\n\n    return ElevatedButton(\n        child: Text('${count()}'),\n        onPressed: () => count.value++\n    );\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"count"})," cell is defined directly in the build function provided to\n",(0,t.jsx)(n.code,{children:"CellWidget.builder"}),". This is functionally equivalent to the\nimplementation using ",(0,t.jsx)(n.code,{children:"StatefulWidget"}),", however much more succinct."]}),"\n",(0,t.jsx)(n.p,{children:"More than one cell can be defined in the build function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Multiple cells defined in CellWidget.builder"',children:"CellWidget.builder((context) {\n    final count1 = MutableCell(0);\n    final count2 = MutableCell(0);\n\n    return Column(\n        children: [\n            ElevatedButton(\n                child: Text('${count1()}'),\n                onPressed: () => count1.value++\n            ),\n            ElevatedButton(\n                child: Text('${count2()}'),\n                onPressed: () => count2.value++\n            )\n        ]\n    );\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"In the example above, two separate cells are defined in a single build\nfunction, each representing a different counter."}),"\n",(0,t.jsxs)(n.admonition,{type:"warning",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{}),(0,t.jsxs)(n.p,{children:["When defining cells directly within ",(0,t.jsx)(n.code,{children:"CellWidget.builder"}),",\nthe definitions should not be placed in:"]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Conditionals"}),"\n",(0,t.jsx)(n.li,{children:"Loops"}),"\n",(0,t.jsxs)(n.li,{children:["Callback and builder functions of widgets nested within the ",(0,t.jsx)(n.code,{children:"CellWidget"}),"."]}),"\n"]})]}),"\n",(0,t.jsxs)(n.admonition,{title:"Examples of good definitions",type:"tip",children:[(0,t.jsxs)(n.p,{children:["The following cell definitions within ",(0,t.jsx)(n.code,{children:"CellWidget.builder"})," are good:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((_) {\n    final a = MutableCell(0);\n    final b = MutableCell(1);\n    ...\n});\n"})})]}),"\n",(0,t.jsxs)(n.admonition,{title:"Examples of badly placed definitions",type:"danger",children:[(0,t.jsxs)(n.p,{children:["The following are examples of badly placed cell definitions in\n",(0,t.jsx)(n.code,{children:"CellWidget.builder"}),". Don't do the following:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((_) {\n    if (...) {\n        // Bad because the definition appears\n        // within a conditional\n        final a = MutableCell(0);\n    }\n    \n    while (...) {\n        // Bad because the definition appears\n        // within a loop\n        final b = MutableCell(1);\n    }\n    \n    return Builder((_) {\n        // Bad because the definition is no longer in\n        // the build function provided to CellWidget.builder,\n        // but in a nested widget builder function.\n        final c = MutableCell(2);\n        ...\n    });\n});\n"})}),(0,t.jsxs)(n.p,{children:["If you end up doing something similar to the above, ",(0,t.jsx)(n.code,{children:"CellWidget"})," will\nnot be able to persist the state of the defined cells between builds."]})]}),"\n",(0,t.jsx)(n.h2,{id:"watching-cells-in-widgets",children:"Watching cells in widgets"}),"\n",(0,t.jsxs)(n.p,{children:["Watch functions can be defined within ",(0,t.jsx)(n.code,{children:"CellWidget.builder"})," using\nthe ",(0,t.jsx)(n.code,{children:".watch"})," method of the ",(0,t.jsx)(n.code,{children:"context"})," provided to the build function."]}),"\n",(0,t.jsxs)(n.p,{children:["Unlike a watch function defined using ",(0,t.jsx)(n.code,{children:"ValueCell.watch"}),", the watch\nfunction is automatically stopped when the ",(0,t.jsx)(n.code,{children:"CellWidget"}),", in which it\nis defined, is removed from the tree."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Watch functions defined with ",(0,t.jsx)(n.code,{children:".watch"})," are only set up once during the\nfirst build."]})}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["The same rules apply to the placement of ",(0,t.jsx)(n.code,{children:".watch"}),", that apply to the\nplacement of cell definitions within ",(0,t.jsx)(n.code,{children:"CellWidget.builder"}),"."]})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Watch function in widget"',children:"CellWidget.builder((context) {\n    final count = MutableCell(0);\n\n    context.watch(() => print('Count ${count()}'));\n\n    return ElevatedButton(\n        child: Text('${count()}'),\n        onPressed: () => count.value++\n    );\n});\n"})}),"\n",(0,t.jsx)(n.h2,{id:"subclassing-cellwidget",children:"Subclassing CellWidget"}),"\n",(0,t.jsxs)(n.p,{children:["We'll be using ",(0,t.jsx)(n.code,{children:"CellWidget.builder"})," throughout the documentation,\nsince its succinct and convenient. However, if you want to make a\nwidget which will be used in more than one place, you should subclass\n",(0,t.jsx)(n.code,{children:"CellWidget"})," instead."]}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"CellWidget"})," subclass can observe and define cells in the ",(0,t.jsx)(n.code,{children:"build"}),"\nmethod, just like ",(0,t.jsx)(n.code,{children:"CellWidget.builder"}),":"]}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsxs)(n.p,{children:["To use the ",(0,t.jsx)(n.code,{children:"watch"})," method, the mixin ",(0,t.jsx)(n.code,{children:"CellHooks"})," has to be included by\nthe subclass, which provides the ",(0,t.jsx)(n.code,{children:"watch"})," method directly to the\nsubclass."]})}),"\n",(0,t.jsxs)(n.p,{children:["The counter example using a ",(0,t.jsx)(n.code,{children:"CellWidget"})," subclass:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="CellWidget subclass"',children:"class Counter extends CellWidget with CellHooks {\n    @override\n    Widget build(BuildContext context) {\n        final count = MutableCell(0);\n\n        watch(() => print('Count: ${count()}'));\n\n        return ElevatedButton(\n            child: Text('${count()}'),\n            onPressed: () => count.value++\n        );\n    }\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["The magic that allows you to define cells directly within\n",(0,t.jsx)(n.code,{children:"CellWidget.builder"})," works by assigning a numerically indexed key to\neach cell that is defined within the build function/method. That's why\nyou should avoid placing definitions within loops and\nconditionals. Cell keys will be covered in the advanced section of the\ndocumentation but if you're curious you can skip ahead to ",(0,t.jsx)(n.a,{href:"/docs/advanced/cell-keys",children:"Cell\nKeys"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>c});var t=i(6540);const l={},d=t.createContext(l);function s(e){const n=t.useContext(d);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),t.createElement(d.Provider,{value:n},e.children)}}}]);