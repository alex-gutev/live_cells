"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[269],{9357:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var t=s(4848),i=s(8453);const r={title:"User Defined Types",description:"Extending cells with accessors for your own classes",sidebar_position:8},a="User Defined Types",o={id:"basics/user-defined-types",title:"User Defined Types",description:"Extending cells with accessors for your own classes",source:"@site/docs/basics/user-defined-types.md",sourceDirName:"basics",slug:"/basics/user-defined-types",permalink:"/docs/basics/user-defined-types",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"User Defined Types",description:"Extending cells with accessors for your own classes",sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"State Restoration",permalink:"/docs/basics/state-restoration"},next:{title:"Lists, Maps and Sets",permalink:"/docs/basics/lists-maps-sets"}},l={},d=[{value:"Live Cell Extension",id:"live-cell-extension",level:2},{value:"Generating the Code",id:"generating-the-code",level:3},{value:"Binding to Properties",id:"binding-to-properties",level:2},{value:"Equality",id:"equality",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"user-defined-types",children:"User Defined Types"}),"\n",(0,t.jsxs)(n.p,{children:["So far we've used cells holding strings and numbers, and an\n",(0,t.jsx)(n.code,{children:"enum"}),". What about types defined by your own classes? A cell can\ngenerally hold a value of any type. This section goes over the tools\nto make working with user defined types more convenient."]}),"\n",(0,t.jsx)(n.h2,{id:"live-cell-extension",children:"Live Cell Extension"}),"\n",(0,t.jsxs)(n.p,{children:["The\n",(0,t.jsx)(n.a,{href:"https://pub.dev/packages/live_cell_extension",children:(0,t.jsx)(n.code,{children:"live_cell_extension"})}),"\npackage provides a source code generator that allows you to extend the\ncore cell interfaces, ",(0,t.jsx)(n.code,{children:"ValueCell"})," and ",(0,t.jsx)(n.code,{children:"MutableCell"}),", with accessors\nfor properties of your own classes."]}),"\n",(0,t.jsx)(n.p,{children:"To understand what this means, consider the following class:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Person class"',children:"class Person {\n    final String firstName;\n    final String lastName;\n    final int age;\n    \n    const Person({\n        required this.firstName,\n        required this.lastName,\n        required this.age\n    });\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's say you have a cell holding a ",(0,t.jsx)(n.code,{children:"Person"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Person cell"',children:"final person = MutableCell(\n    Person(\n        firstName: 'John',\n        lastName: 'Smith',\n        age: 25\n    )\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To access a property of the ",(0,t.jsx)(n.code,{children:"Person"})," held in the cell, you will need\nto defined a computed cell:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Accessing properties in cells"',children:"final firstName = ValueCell.computed(() => person().firstName);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you want the ",(0,t.jsx)(n.code,{children:"firstName"})," cell to be settable, so that setting the\nvalue of ",(0,t.jsx)(n.code,{children:"firstName"})," updates the ",(0,t.jsx)(n.code,{children:"person"})," cell, you'll need to define\na ",(0,t.jsx)(n.code,{children:"copyWith"})," method and a mutable computed cell:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Mutating properties in cells"',children:"final firstName = MutableCell.computed(() => person().firstName, (name) {\n    person.value = person.value.copyWith(\n        firstName: name\n    );\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is the definition of boilerplate and will quickly become tiring."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"live_cell_extension"})," package automatically generates this code\nfor you, so that instead of the above, you can write the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Generated ValueCell property accessors"',children:"final firstName = person.firstName;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["And to update the value of the ",(0,t.jsx)(n.code,{children:"firstName"})," property:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Generated MutableCell property accessors"',children:"person.firstName.value = 'Jane';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["That's it, no need to write a ",(0,t.jsx)(n.code,{children:"copyWith"})," method either. This ties in\nwith Live Cell's design principle that cells should be\nindistinguishable, as much as is possible, from the values they hold."]}),"\n",(0,t.jsx)(n.h3,{id:"generating-the-code",children:"Generating the Code"}),"\n",(0,t.jsxs)(n.p,{children:["To make this work you'll need to add the ",(0,t.jsx)(n.code,{children:"live_cell_extension"})," package\nto the ",(0,t.jsx)(n.code,{children:"dev_dependencies"})," of your ",(0,t.jsx)(n.code,{children:"pubspec.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"dev_dependencies:\n    live_cell_extension: 0.6.1\n    ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then annotate the classes, for which you want accessors to be\ngenerated, with ",(0,t.jsx)(n.code,{children:"CellExtension"}),". If you want mutable cell accessors to\nalso be generated, add ",(0,t.jsx)(n.code,{children:"mutable: true"})," to the annotation arguments."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="person.dart"',children:"part 'person.g.dart';\n\n@CellExtension(mutable: true)\nclass Person {\n    final String firstName;\n    final String lastName;\n    final int age;\n    \n    const Person({\n        required this.firstName,\n        required this.lastName,\n        required this.age\n    });\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["Don't forget to include the ",(0,t.jsx)(n.code,{children:"<filename>.g.dart"})," file. This is where\nthe code will be generated."]})}),"\n",(0,t.jsx)(n.p,{children:"Next you'll need to run the following command in the root directory of\nyour project:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"dart run build_runner build\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will generate the ",(0,t.jsx)(n.code,{children:".g.dart"})," files, which contain the generated\nclass property accessors."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ValueCell"})," accessors are defined in an extension with the name of\nthe class followed by ",(0,t.jsx)(n.code,{children:"CellExtension"}),". The ",(0,t.jsx)(n.code,{children:"MutableCell"})," accessors are\ndefined in an extension with the name of the class followed by\n",(0,t.jsx)(n.code,{children:"MutableCellExtension"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"binding-to-properties",children:"Binding to Properties"}),"\n",(0,t.jsx)(n.p,{children:"Using the generated property accessors, we can define a form for\npopulating the class properties simply by binding the property cells,\nretrieved using the generated accessors, to the appropriate widgets."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Binding directly to properties"',children:"class PersonForm extends CellWidget {\n    final MutableCell<Person> person;\n    \n    PersonForm(this.person);\n    \n    @override\n    Widget build(BuildContext context) => Column(\n    children: [\n        Text('First Name:'),\n        LiveTextField(\n            content: person.firstName\n        ),\n        Text('Last Name:'),\n        LiveTextField(\n            content: person.lastName\n        ),\n        Text('Age:'),\n        Numberfield(person.age)\n    ]\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We used the ",(0,t.jsx)(n.code,{children:"Numberfield"})," widget, defined ",(0,t.jsx)(n.a,{href:"error-handling",children:"earlier"}),", for the ",(0,t.jsx)(n.code,{children:"age"}),"\nproperty."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"We defined the form as a class because we intend to reuse it in other\nwidgets."})}),"\n",(0,t.jsx)(n.p,{children:"We can then use this form as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((_) {\n  final person = MutableCell(\n      Person(\n          firstName: 'John',\n          lastName: 'Smith',\n          age: 25\n      )\n  );\n    \n  return Column(\n    children: [\n      PersonForm(person),\n      Text('${person.firstName()} ${person.lastName()}: ${person.age()} years'),\n      ElevatedButton(\n        child: Text('Save'),\n        // A hypothetical savePerson function\n        onPressed: () => savePerson(person.value)\n      ),\n      ElevatedButton(\n        child: Text('Reset'),\n        onPressed: () => person.value = Person(\n          firstName: 'John',\n          lastName: 'Smith',\n          age: 25\n        )\n      )\n    ]\n  );\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example we used the ",(0,t.jsx)(n.code,{children:"personForm"})," widget defined earlier."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The details of the person are displayed in a ",(0,t.jsx)(n.code,{children:"Text"}),", which is\nautomatically updated when the person's details are changed."]}),"\n",(0,t.jsxs)(n.li,{children:['The "Save" button saves the entered details, which are held in the\n',(0,t.jsx)(n.code,{children:"person"})," cell."]}),"\n",(0,t.jsxs)(n.li,{children:['The "Reset" button resets the form fields to their defaults by\ndirectly assigning a default ',(0,t.jsx)(n.code,{children:"Person"})," to the ",(0,t.jsx)(n.code,{children:"person"})," cell."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The benefits of this, as opposed to using the tools already available\nin Flutter, are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No need to write event handlers and state synchronization code for\nacquiring input from the user. This is all handled automatically."}),"\n",(0,t.jsxs)(n.li,{children:["You can focus directly on the representation of your data and think\nin terms of your data, rather than thinking in terms of widget ",(0,t.jsx)(n.code,{children:"State"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Your widgets are bound directly to your data and kept in sync. There\nis no chance of you accidentally forgetting to synchronize them with\nyour data and vice versa, which eliminates a whole class of bugs."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"equality",children:"Equality"}),"\n",(0,t.jsxs)(n.p,{children:["It is a good practice to define the ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"hashCode"})," methods on\nclasses which will be used as cell value types. In-fact there are two\nsituations, in which defining ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"hashCode"})," is essential:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"When a constant cell holding an instance of the class is created:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final person = Person(...).cell;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"Person"})," does not override ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"hashCode"}),", each call to\n",(0,t.jsx)(n.code,{children:"Person(...).cell"})," will create a new cell even if the same values\nare given for the ",(0,t.jsx)(n.code,{children:"firstName"}),", ",(0,t.jsx)(n.code,{children:"lastName"})," and ",(0,t.jsx)(n.code,{children:"age"})," properties."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["When ",(0,t.jsx)(n.code,{children:"changesOnly: true"})," is given to a cell holding an instance of the class:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final person = ValueCell.computed(() => Person(\n    firstName: firstName(),\n    lastName: lastName(),\n    age: age()\n), changesOnly: true)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"Person"})," does not override ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"hashCode"}),", the\n",(0,t.jsx)(n.code,{children:"changesOnly"})," keyword has no effect, since every time the cell is\nrecomputed, a new ",(0,t.jsx)(n.code,{children:"Person"})," is created that is never equal to the\nprevious ",(0,t.jsx)(n.code,{children:"Person"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"live_cell_extension"})," package also generates a comparison and hash\nfunction for classes annotated with ",(0,t.jsx)(n.code,{children:"CellExtension"}),". The name of the\ncomparison function is of the form ",(0,t.jsx)(n.code,{children:"_$<class>Equals"})," and the name of\nthe hash function is of the form ",(0,t.jsx)(n.code,{children:"_$<class>HashCode"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Thus to override ",(0,t.jsx)(n.code,{children:"=="})," and ",(0,t.jsx)(n.code,{children:"hashCode"})," for the ",(0,t.jsx)(n.code,{children:"Person"})," class, all that\nhas to be done is the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"@CellExtension(mutable: true)\nclass Person {\n    final String firstName;\n    final String lastName;\n    final int age;\n    \n    const Person({\n        required this.firstName,\n        required this.lastName,\n        required this.age\n    });\n\n    @override\n    bool operator ==(Object other) =>\n        _$PersonEquals(this, other);\n        \n    @override\n    int get hashCode => _$PersonHashCode(this);\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"_$PersonEquals"})," and ",(0,t.jsx)(n.code,{children:"_$PersonHashCode"})," are the generated comparison\nand hash functions respectively."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["If you don't want comparison and hash functions to be generated, pass\n",(0,t.jsx)(n.code,{children:"generateEquals: false"})," to the ",(0,t.jsx)(n.code,{children:"CellExtension"})," annotation."]})}),"\n",(0,t.jsxs)(n.p,{children:["By default the generated comparison function compares each property\nwith ",(0,t.jsx)(n.code,{children:"=="})," and the generated hash function computes the hash code\nusing the ",(0,t.jsx)(n.code,{children:"hashCode"})," property of each property. To specify a different\ncomparison and hash function for a property, annotate it with\n",(0,t.jsx)(n.code,{children:"DataField"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"@CellExtension()\nclass Point {\n    @DataField(\n        equals: listEquals,\n        hash: Object.hashAll\n    )\n    final List<int> coordinates;\n    \n    ...\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"equals"})," argument specifies the comparison function to use instead\nof ",(0,t.jsx)(n.code,{children:"=="})," and the ",(0,t.jsx)(n.code,{children:"hash"})," argument specifies the hash function to use\ninstead of the ",(0,t.jsx)(n.code,{children:"hashCode"})," property."]})}),"\n",(0,t.jsxs)(n.p,{children:["In this example the generated comparison function for the ",(0,t.jsx)(n.code,{children:"Point"}),"\nclass, will use ",(0,t.jsx)(n.code,{children:"listEquals"}),", from the ",(0,t.jsx)(n.code,{children:"flutter:foundation.dart"}),"\nlibrary to compare the values of the ",(0,t.jsx)(n.code,{children:"coordinates"}),"\nproperties. Similarly, the generated hash function will use\n",(0,t.jsx)(n.code,{children:"Object.hashAll"})," to compute the hash code of the ",(0,t.jsx)(n.code,{children:"coordinates"}),"\nproperty."]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["If you only want to generate a comparison and hash function but do not\nwant to generate a cell extension, annotate the class with\n",(0,t.jsx)(n.code,{children:"@DataClass()"}),"."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);