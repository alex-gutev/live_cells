"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[245],{427:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>r});var l=n(4848),i=n(8453);const s={title:"Meta Cells",description:"Dependency inversion using meta cells",sidebar_position:12},a="Meta Cells",c={id:"basics/meta-cells",title:"Meta Cells",description:"Dependency inversion using meta cells",source:"@site/docs/basics/meta-cells.md",sourceDirName:"basics",slug:"/basics/meta-cells",permalink:"/docs/basics/meta-cells",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:12,frontMatter:{title:"Meta Cells",description:"Dependency inversion using meta cells",sidebar_position:12},sidebar:"tutorialSidebar",previous:{title:"Action Cells",permalink:"/docs/basics/action-cells"},next:{title:"Effect Cells",permalink:"/docs/basics/effect-cells"}},o={},r=[{value:"Differences from Mutable Cells",id:"differences-from-mutable-cells",level:2}];function h(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(t.h1,{id:"meta-cells",children:"Meta Cells"}),"\n",(0,l.jsxs)(t.p,{children:["A ",(0,l.jsx)(t.em,{children:"meta cell"})," is a cell that points to another cell. Accessing the\n",(0,l.jsx)(t.code,{children:"value"})," of a meta cell, accesses the value of the cell it\npoints to. Similarly, observers of the meta cell are notified when the\nvalue of the cell it points to changes."]}),"\n",(0,l.jsxs)(t.p,{children:["Meta cells are created with the ",(0,l.jsx)(t.code,{children:"MetaCell"})," constructor, and initially\ndo not point to any cell."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-dart",metastring:'title="Creating a meta cell"',children:"final m = MetaCell<int>();\n"})}),"\n",(0,l.jsx)(t.admonition,{type:"note",children:(0,l.jsxs)(t.p,{children:[(0,l.jsx)(t.code,{children:"MetaCell"})," is a generic class with a single type parameter, which is\nthe cell value type, ",(0,l.jsx)(t.code,{children:"int"})," in the example above. This has to be\nspecified manually when creating the ",(0,l.jsx)(t.code,{children:"MetaCell"}),", since the constructor\ndoes not take any arguments, from which it can be deduced."]})}),"\n",(0,l.jsxs)(t.p,{children:["Observers can be added and removed before the meta cell is pointing to\nanother cell, but accessing its value will result in an\n",(0,l.jsx)(t.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/EmptyMetaCellError-class.html",children:(0,l.jsx)(t.code,{children:"EmptyMetaCellError"})}),"\nexception being thrown."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-dart",children:"// This is OK\nm.addObserver(...)\n\n// This will throw EmptyMetaCellError\nprint(m.value)\n"})}),"\n",(0,l.jsxs)(t.p,{children:["The cell to which a meta cell points to is set with the\n",(0,l.jsx)(t.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/MetaCell/inject.html",children:(0,l.jsx)(t.code,{children:"inject"})}),"\nmethod, which takes the cell as an argument. Once a cell has been\n",(0,l.jsx)(t.em,{children:"injected"})," in a meta cell, accessing the meta cell's value returns the\nvalue of the injected cell."]}),"\n",(0,l.jsxs)(t.p,{children:["The ",(0,l.jsx)(t.code,{children:"inject"})," method can be called multiple times. If the meta cell,\nalready points to a cell when ",(0,l.jsx)(t.code,{children:"inject"})," is called, the meta cell now\npoints to the new cell. The value of the meta cell is the value of the\nnewly ",(0,l.jsx)(t.em,{children:"injected cell"}),", and similarly the observers of the meta cell\nare notified whenever the observers of the injected cell are notified."]}),"\n",(0,l.jsx)(t.pre,{children:(0,l.jsx)(t.code,{className:"language-dart",metastring:".inject() method",children:"final a = MutableCell(0);\nfinal b = MutableCell(1);\n\nfinal m = MetaCell<int>();\n\nm.inject(a);\n\n// Called when `m` notifies its observers\nValueCell.watch(() => print(m.value));\n\na.value = 2; // Prints 2\na.value = 3; // Prints 3\n\nm.inject(b);\n\n// Doesn't print anything since `m` no\n// longer points to `a`\na.value = 4;\n\n// Prints 15\nb.value = 15;\n"})}),"\n",(0,l.jsx)(t.admonition,{type:"important",children:(0,l.jsxs)(t.p,{children:["A meta cell ",(0,l.jsx)(t.strong,{children:"does not"})," notify its observers when the cell it points\nto is changed with ",(0,l.jsx)(t.code,{children:".inject"}),"."]})}),"\n",(0,l.jsxs)(t.p,{children:["Meta cells allow for a rudimentary form of ",(0,l.jsx)(t.em,{children:"dependency\ninversion"}),". They are useful when you need to observe a cell without\ncontrolling how the cell is created."]}),"\n",(0,l.jsx)(t.h2,{id:"differences-from-mutable-cells",children:"Differences from Mutable Cells"}),"\n",(0,l.jsx)(t.p,{children:"Meta cells are different from mutable cells, in that a meta cell does\nnot actually implement the functionality of a cell but delegates its\nimplementation to the cell it points to, whereas a mutable cell is an\nactual implementation of a cell that can have its value set. Meta\ncells do not allow their value to be set, but only allow changing the\ncell to which the meta cell points to."}),"\n",(0,l.jsx)(t.admonition,{type:"note",children:(0,l.jsx)(t.p,{children:"In the current version of Live Cells, setting the value of a cell via\na meta cell is not supported."})})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,l.jsx)(t,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>c});var l=n(6540);const i={},s=l.createContext(i);function a(e){const t=l.useContext(s);return l.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),l.createElement(s.Provider,{value:t},e.children)}}}]);