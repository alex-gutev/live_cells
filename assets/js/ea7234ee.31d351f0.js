"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[237],{7943:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>a});var s=l(4848),t=l(8453);const r={title:"ValueCell Subclass 1",description:"Part one of how to write your own ValueCell subclass",sidebar_position:3},i="ValueCell Subclass 1",d={id:"advanced/writing-cells-1",title:"ValueCell Subclass 1",description:"Part one of how to write your own ValueCell subclass",source:"@site/docs/advanced/writing-cells-1.md",sourceDirName:"advanced",slug:"/advanced/writing-cells-1",permalink:"/docs/advanced/writing-cells-1",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"ValueCell Subclass 1",description:"Part one of how to write your own ValueCell subclass",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Cell Keys",permalink:"/docs/advanced/cell-keys"}},o={},a=[{value:"Custom Cells with Arguments",id:"custom-cells-with-arguments",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"valuecell-subclass-1",children:"ValueCell Subclass 1"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ValueCell-class.html",children:(0,s.jsx)(n.code,{children:"ValueCell"})}),"\nis the base class implemented by all cells. This class defines the\ncell interface which consists of the following methods:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ValueCell/addObserver.html",children:(0,s.jsx)(n.code,{children:"addObserver"})})}),"\n",(0,s.jsx)(n.p,{children:"Adds an observer that is notified when the value of the cell changes."}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ValueCell/removeObserver.html",children:(0,s.jsx)(n.code,{children:"removeObserver"})})}),"\n",(0,s.jsxs)(n.p,{children:["Removes an observer, previously added with ",(0,s.jsx)(n.code,{children:"addObserver"}),", so that it\nis no longer notified when the value of the cell changes."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"and the following property:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ValueCell/value.html",children:(0,s.jsx)(n.code,{children:"value"})})}),"\n",(0,s.jsx)(n.p,{children:"The value of the cell, which can either be retrieved from memory or\ncomputed on demand."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["To implement your own ",(0,s.jsx)(n.code,{children:"ValueCell"})," subclass, you have to implement\nthese methods and properties. For example to implement a cell that\ncomputes a random value, whenever its value is accessed, the ",(0,s.jsx)(n.code,{children:"value"}),"\nproperty has to be overridden:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="Custom cell that returns a random value"',children:"class RandomCell extends ValueCell<int> {\n  final int max;\n  \n  const RandomCell([this.max = 10]);\n\n  @override\n  int get value => Random().nextInt(max);\n\n  @override\n  void addObserver(CellObserver observer) {}\n\n  @override\n  void removeObserver(CellObserver observer) {}\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"value"})," property is overridden with a property that returns a\nrandom integer. Note, a new random integer is returned whenever the\nvalue of the cell is accessed."]}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"addObserver"})," and ",(0,s.jsx)(n.code,{children:"removeObserver"})," methods are overridden, since\nthese methods are not defined by the base ",(0,s.jsx)(n.code,{children:"ValueCell"})," class. These\nmethods are left empty since the cell never notifies its observers\nthat its value has changed and thus there is no need to keep track of\nobservers."]}),"\n",(0,s.jsx)(n.h2,{id:"custom-cells-with-arguments",children:"Custom Cells with Arguments"}),"\n",(0,s.jsxs)(n.p,{children:["To define a ",(0,s.jsx)(n.code,{children:"ValueCell"})," subclass with a value that is dependent on\nother cells, extend the\n",(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells_core/latest/live_cells_internals/DependentCell-class.html",children:(0,s.jsx)(n.code,{children:"DependentCell"})}),"\nclass. This class provides a constructor which accepts the set of\nargument cells on which the value of the cell depends. Whenever the\nvalue of at least one of the cells in this set changes, the observers\nof the ",(0,s.jsx)(n.code,{children:"DependentCell"})," are notified. Only the ",(0,s.jsx)(n.code,{children:"value"})," property has to\nbe overridden by subclasses, since ",(0,s.jsx)(n.code,{children:"DependentCell"})," provides\nimplementations of ",(0,s.jsx)(n.code,{children:"addObserver"})," and ",(0,s.jsx)(n.code,{children:"removeObserver"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Here's an example of the previous ",(0,s.jsx)(n.code,{children:"RandomCell"})," however with the\n",(0,s.jsx)(n.em,{children:"maximum"})," now provided in an argument cell rather than a value."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"class RandomCell extends DependentCell<int> {\n  final ValueCell<int> max;\n  \n  const RandomCell(this.max) : super({max});\n  \n  @override \n  int get value => Random().nextInt(max.value);\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Some points to note from this example:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"max"})," is now a ",(0,s.jsx)(n.code,{children:"ValueCell"})," which is included in the argument cell\nset provided to the ",(0,s.jsx)(n.code,{children:"super"})," constructor."]}),"\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"value"})," property is accessed directly since ",(0,s.jsx)(n.code,{children:"DependentCell"})," does\nnot determine argument cells dynamically."]}),"\n"]}),"\n",(0,s.jsx)(n.admonition,{type:"important",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"DependentCell"})," is a stateless cell that does not cache its\nvalue. Instead it's value is recomputed whenever it is accessed."]})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>i,x:()=>d});var s=l(6540);const t={},r=s.createContext(t);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);