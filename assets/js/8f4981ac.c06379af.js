"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[897],{7587:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>r});var i=t(4848),s=t(8453);const l={title:"Effect Cells",description:"Observing the result of side effects using cells",sidebar_position:13},c="Effect Cells",o={id:"basics/effect-cells",title:"Effect Cells",description:"Observing the result of side effects using cells",source:"@site/docs/basics/effect-cells.md",sourceDirName:"basics",slug:"/basics/effect-cells",permalink:"/docs/basics/effect-cells",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:13,frontMatter:{title:"Effect Cells",description:"Observing the result of side effects using cells",sidebar_position:13},sidebar:"tutorialSidebar",previous:{title:"Meta Cells",permalink:"/docs/basics/meta-cells"},next:{title:"Self Cells",permalink:"/docs/basics/self-cells"}},d={},r=[{value:"Observing Side Effects",id:"observing-side-effects",level:2},{value:"Loading Indicator",id:"loading-indicator",level:3},{value:"Performing Actions",id:"performing-actions",level:3},{value:"Observing Cells in Effect Cells",id:"observing-cells-in-effect-cells",level:2},{value:"Cell Buttons",id:"cell-buttons",level:2},{value:"Code Organization",id:"code-organization",level:2},{value:"Why use Effect Cells?",id:"why-use-effect-cells",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"effect-cells",children:"Effect Cells"}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.em,{children:"effect cell"})," is a cell that performs a side effect and allows the\nresult/status of the effect to be observed by observing a cell."]}),"\n",(0,i.jsxs)(n.p,{children:["An effect cell is tied to an ",(0,i.jsx)(n.a,{href:"action-cells",children:"action cell"}),". This means\nthat the side effect, which is defined in the value computation\nfunction of the effect cell, only runs when the action cell is\ntriggered, and only once per trigger."]}),"\n",(0,i.jsxs)(n.p,{children:["Effect cells are created using the\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ActionCellEffectExtension/effect.html",children:(0,i.jsx)(n.code,{children:".effect"})}),"\nmethod provided by action cells (",(0,i.jsx)(n.code,{children:"ValueCell<void>"}),"). The side effect\nis defined in the function provided to ",(0,i.jsx)(n.code,{children:"effect"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Creating an effect cell"',children:"final ValueCell<void> action;\n\n...\n\nfinal effect = action.effect(() {\n    // A hypothetical form submission\n    return submitForm();\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, an effect cell (",(0,i.jsx)(n.code,{children:"effect"}),") is created that is\ntied to an ",(0,i.jsx)(n.code,{children:"action"})," cell. The side effect, defined by ",(0,i.jsx)(n.code,{children:"effect"})," is a\nform submission effected by the (hypothetical) ",(0,i.jsx)(n.code,{children:"submitForm()"}),"\nfunction. The ",(0,i.jsx)(n.code,{children:"submitForm"})," function is run whenever ",(0,i.jsx)(n.code,{children:"action"})," is\ntriggered. Notice the value of ",(0,i.jsx)(n.code,{children:"submitForm()"})," is returned in the\neffect function. This becomes the value of the effect cell which\nallows us to observe the result/status of the effect by observing the\n",(0,i.jsx)(n.code,{children:"effect"})," cell."]}),"\n",(0,i.jsxs)(n.p,{children:["This is different from ",(0,i.jsx)(n.code,{children:"ValueCell.watch"})," in the following ways:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The result of the side effect can be observed by observing the\neffect cell ",(0,i.jsx)(n.code,{children:"effect"}),", in this case. This is useful for displaying a\nloading indicator while the side effect is in progress."]}),"\n",(0,i.jsxs)(n.li,{children:["The side effect function is only run when the action cell is\ntriggered, whereas ",(0,i.jsx)(n.code,{children:"ValueCell.watch"})," is run once initially when it\nis defined in order to discover its dependencies."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The difference between an effect cell and a regular computed cell is\nthat the effect cell guarantees that the compute value function will\nonly be run once per trigger of the action to which it is tied. On the\nother hand a computed cells is intended to be used with a pure function\nthat computes a value, and thus makes no guarantees about how many times\nits compute function is called."}),"\n",(0,i.jsx)(n.admonition,{type:"important",children:(0,i.jsx)(n.p,{children:"An effect cell has to be observed, and its value referenced, in order\nfor the side effect to be run. If the action cell is triggered, but\nthe effect cell has no observers, the side effect is not run."})}),"\n",(0,i.jsx)(n.h2,{id:"observing-side-effects",children:"Observing Side Effects"}),"\n",(0,i.jsx)(n.p,{children:"As mentioned earlier, effect cells are useful for observing the\nresult/status of a side effect. In the following examples, we'll\ndefine an effect cell that simulates a form submission, and observe it\nto display a loading indicator while the submission is ongoing."}),"\n",(0,i.jsx)(n.p,{children:"First let's define a widget, with an action cell that is triggered by\na button."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class Example extends CellWidget with CellHooks {\n  @override\n  Widget build(BuildContext context) {\n    final submit = ActionCell();\n    \n    return ElevatedButton(\n      onPressed: submit.trigger\n      child: Text('Submit')\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["We've included the\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/CellHooks-mixin.html",children:(0,i.jsx)(n.code,{children:"CellHooks"})}),"\nmixin since we'll be using the\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/CellHooks/watch.html",children:(0,i.jsx)(n.code,{children:"watch"})}),"\nmethod."]})}),"\n",(0,i.jsxs)(n.p,{children:["Now let's define the effect that is run when the ",(0,i.jsx)(n.code,{children:"submit"})," action cell\nis triggered, which happens when the button is pressed."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Widget build(BuildContext context) {\n  final submit = ActionCell();\n    \n  final submission = submit.effect(() async {\n    return await Future.delayed(Duration(seconds: 3), () => true);\n  });\n    \n  ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We've used ",(0,i.jsx)(n.code,{children:"Future.delayed"})," to simulate a network request, with\n",(0,i.jsx)(n.code,{children:"true"}),", indicating success, returned after three seconds. In a real\napplication, you would substitute ",(0,i.jsx)(n.code,{children:"Future.delayed"})," with an actual\nHTTP request."]}),"\n",(0,i.jsx)(n.p,{children:"There are two things we want to achieve:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Display a loading indicator while the submission is in progress."}),"\n",(0,i.jsx)(n.li,{children:"Display a dialog with a message indicating whether the request\nsucceeded or failed."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"loading-indicator",children:"Loading Indicator"}),"\n",(0,i.jsxs)(n.p,{children:["To display the loading indicator we can simply observe the\n",(0,i.jsx)(n.code,{children:"submission"})," effect cell, and use ",(0,i.jsx)(n.code,{children:"isComplete"}),", from ",(0,i.jsx)(n.a,{href:"async-cells#checking-if-complete",children:"Asynchronous\nCells"}),", to conditionally display the\nindicator."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Widget build(BuildContext context) {\n  ...\n  \n  final isLoading = !submission.isComplete();\n  \n  return ElevatedButton(\n    onPressed: isLoading ? null : submit.trigger\n    child: isLoading ? CircularProgressIndicator() : Text('Submit')\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"submission.isComplete()"})," is false, a progress indicator is\ndisplayed in the button and the ",(0,i.jsx)(n.code,{children:"onPressed"})," callback is ",(0,i.jsx)(n.code,{children:"null"}),", which\ndisables the button while the submission is in progress."]}),"\n",(0,i.jsxs)(n.p,{children:["When the ",(0,i.jsx)(n.code,{children:"submission"})," effect cell is accessed before the effect has\nrun for the first time, an ",(0,i.jsx)(n.code,{children:"UninitializedCellError"})," exception is\nthrown. In this case ",(0,i.jsx)(n.code,{children:"submission.isComplete()"})," is true since the value\nof ",(0,i.jsx)(n.code,{children:"submission"})," is not a ",(0,i.jsx)(n.code,{children:"Future"})," that is pending, therefore the\nprogress indicator is not shown until the button is pressed."]}),"\n",(0,i.jsxs)(n.p,{children:["Pressing the button results in the progress indicator being shown\nuntil the ",(0,i.jsx)(n.code,{children:"Future"})," held in ",(0,i.jsx)(n.code,{children:"submission"}),' completes, which in this\n"simulated" example happens after three seconds.']}),"\n",(0,i.jsx)(n.h3,{id:"performing-actions",children:"Performing Actions"}),"\n",(0,i.jsxs)(n.p,{children:["To show the dialog we can observe the ",(0,i.jsx)(n.code,{children:"submission"})," effect cell in a\ncell watch function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Widget build(BuildContext context) {\n  final submission = ...;\n    \n  watch(() {\n    final result = effect.awaited();\n    \n    if (context.mounted) {\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: Text(result \n              ? 'Success' \n              : 'Error'\n          ),\n          content: Text(result\n              ? 'The submission was successful'\n              : 'Please try again'\n          ),\n          \n          actions: [\n            ElevatedButton(\n              onPressed: () => Navigator.pop(context),\n              child: Text('OK')\n            )\n          ]\n        )\n      );\n    }\n  });\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["We've used the ",(0,i.jsx)(n.code,{children:"watch"})," method provided by ",(0,i.jsx)(n.code,{children:"CellHooks"})," rather than\n",(0,i.jsx)(n.code,{children:"ValueCell.watch"})," since watch functions defined using the former are\nregistered once during the first build and automatically stopped when\nthe widget is unmounted."]})}),"\n",(0,i.jsxs)(n.p,{children:["A watch function is defined that observes the result of the side\neffect using ",(0,i.jsx)(n.code,{children:"submission.awaited"}),". The watch function, which displays\na dialog showing the status of the submission, is only run when the\n",(0,i.jsx)(n.code,{children:"submit"})," action cell is triggered and the ",(0,i.jsx)(n.code,{children:"Future"})," held in\n",(0,i.jsx)(n.code,{children:"submission"})," is completed. This is because ",(0,i.jsx)(n.code,{children:"submission.awaited"})," throws\nan exception until the effect is run and the ",(0,i.jsx)(n.code,{children:"Future"}),", returned by the\neffect function, has completed. The exception prevents the remainder\nof the function from being run."]}),"\n",(0,i.jsxs)(n.p,{children:["Success is indicated by a return value of ",(0,i.jsx)(n.code,{children:"true"})," in the effect\nfunction and failure by a return value of ",(0,i.jsx)(n.code,{children:"false"}),". The value returned\nby the ",(0,i.jsx)(n.code,{children:"submission"})," effect is checked inside the watch function to\nchoose which dialog to display."]}),"\n",(0,i.jsxs)(n.p,{children:["You'll notice a number of unhandled exception notices being printed to\nthe console when running in debug mode. These are expected because\n",(0,i.jsx)(n.code,{children:"submission.awaited"})," throws an exception until it has a result, and\nthese are not handled inside the watch function. To silence the\n",(0,i.jsx)(n.code,{children:"UninitializedCellError"})," and ",(0,i.jsx)(n.code,{children:"PendingAsyncValueError"})," exceptions, use\n",(0,i.jsx)(n.code,{children:".whenReady"}),". This has the same effect of terminating the watch\nfunction, but prevents unhandled ",(0,i.jsx)(n.code,{children:"UninitializedCellError"})," and\n",(0,i.jsx)(n.code,{children:"PendingAsyncValueError"})," exception notices from being printed to the\nconsole."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Silencing unhandled exception notices with .whenReady"',children:"watch(() {\n  final result = effect.awaited.whenReady();\n    \n  if (context.mounted) {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text(result \n            ? 'Success' \n            : 'Error'\n        ),\n        content: Text(result\n            ? 'The submission was successful'\n            : 'Please try again'\n        ),\n        \n        actions: [\n          ElevatedButton(\n            onPressed: () => Navigator.pop(context),\n            child: Text('OK')\n          )\n        ]\n      )\n    );\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"observing-cells-in-effect-cells",children:"Observing Cells in Effect Cells"}),"\n",(0,i.jsxs)(n.p,{children:["The value of another cell can be referenced inside an effect cell\nfunction using the same function call syntax used within\n",(0,i.jsx)(n.code,{children:"ValueCell.computed"}),". However, the difference is that changes in the\nvalue of the referenced cell will not cause the effect function to be\nrun again. The effect function is only run when the action cell, to\nwhich it is tied to, is triggered."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's add some data to the submission. We'll add a switch, which when\nit is on the submission succeeds and when it is off the submission\nfails. We'll use ",(0,i.jsx)(n.code,{children:"CellSwitch"})," to bind the state of the switch directly\nto a cell."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Widget build(BuildContext context) {\n  final submit = ActionCell();\n\n  final succeed = MutableCell(true);\n\n  final submission = submit.effect(() async {\n    final result = succeed();\n    \n    return await Future.delayed(Duration(seconds: 3), () => result);\n  });\n\n  ...\n  \n  return Column(\n    children: [\n      CellSwitch(\n          value: succeed,\n          enabled: submission.isComplete;\n      ),\n      ElevatedButton(\n          onPressed: isLoading ? null : submit.trigger\n          child: isLoading \n             ? CircularProgressIndicator() \n             : Text('Submit')\n      )\n    ]\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Toggling the switch will now change the result of the ",(0,i.jsx)(n.code,{children:"submission"}),"\ncell, though as mentioned earlier the side effect defined by the\n",(0,i.jsx)(n.code,{children:"submission"})," cell is only run when the button is\npressed. Additionally, ",(0,i.jsx)(n.code,{children:"submission.isComplete"})," is bound to the\n",(0,i.jsx)(n.code,{children:"enabled"})," property of the ",(0,i.jsx)(n.code,{children:"CellSwitch"}),". As a result, the switch is\ndisabled while the submission is still in progress."]}),"\n",(0,i.jsx)(n.h2,{id:"cell-buttons",children:"Cell Buttons"}),"\n",(0,i.jsxs)(n.p,{children:["So far we've used a callback function to handle the button press\nevents, which does nothing other than trigger an action cell. This\nlibrary provides a\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cell_widgets/CellElevatedButton-class.html",children:(0,i.jsx)(n.code,{children:"CellElevatedButton"})}),"\nwhich allows you to directly specify an action cell that is triggered\nby button press events without having to provide a callback."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CellElevatedButton"})," takes a ",(0,i.jsx)(n.code,{children:"press"})," argument rather than an\n",(0,i.jsx)(n.code,{children:"onPressed"})," argument, which takes a ",(0,i.jsx)(n.code,{children:"MetaCell<void>"})," rather than a\ncallback. When the button is constructed an action cell is injected\ninto the meta cell passed to ",(0,i.jsx)(n.code,{children:"press"})," and is triggered whenever the\nbutton is pressed."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The action button takes a ",(0,i.jsx)(n.code,{children:"MetaCell"})," rather than an ",(0,i.jsx)(n.code,{children:"ActionCell"})," since\ntriggering the action outside the button will not result in any\nchanges to the button. This is different from ",(0,i.jsx)(n.code,{children:"CellSwitch"})," which takes\na ",(0,i.jsx)(n.code,{children:"MutableCell"}),". When the cell is set from outside the switch, the\nstate of the switch changes."]})}),"\n",(0,i.jsxs)(n.p,{children:["To replace ",(0,i.jsx)(n.code,{children:"ElevatedButton"})," with ",(0,i.jsx)(n.code,{children:"CellElevatedButton"})," we first have to\nchange the definition of ",(0,i.jsx)(n.code,{children:"submit"})," to the following:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final submit = MetaCell<void>();\n...\nCellElevatedButton(\n    press: submit,\n    enabled: submission.isComplete,\n    child: isLoading \n        ? CircularProgressIndicator().cell\n        : Text('Submit').cell\n)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Note, the ",(0,i.jsx)(n.code,{children:"submit"})," cell is passed to the ",(0,i.jsx)(n.code,{children:"press"})," argument of\n",(0,i.jsx)(n.code,{children:"CellElevatedButton"}),". This button also takes an ",(0,i.jsx)(n.code,{children:"enabled"})," argument,\nunlike ",(0,i.jsx)(n.code,{children:"ElevatedButton"}),", for which we've supplied\n",(0,i.jsx)(n.code,{children:"submission.isComplete"}),". As a result the button is enabled before the\neffect has run and after it has completed, but is disabled while the\nresult is still pending."]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CellElevatedButton"})," also accepts meta cells for ",(0,i.jsx)(n.code,{children:"longPress"}),",\n",(0,i.jsx)(n.code,{children:"onHover"})," and ",(0,i.jsx)(n.code,{children:"onFocusChange"})," for handling long press, hover and focus\nchange events."]})}),"\n",(0,i.jsx)(n.h2,{id:"code-organization",children:"Code Organization"}),"\n",(0,i.jsxs)(n.p,{children:["So far not much thought has been given to the organization of our\ncode. Instead we've directly placed all the cell definitions in the\n",(0,i.jsx)(n.code,{children:"build"})," method of the widget. For this simple example its not an issue\nbut for larger applications its best to separate the cell definitions\nfrom the UI."]}),"\n",(0,i.jsxs)(n.p,{children:["A recommended approach for achieving separation of concerns is to use\ncell factory functions. This is a fancy term for a function which\ncreates a cell. For example, the ",(0,i.jsx)(n.code,{children:"submit"})," action cell and ",(0,i.jsx)(n.code,{children:"submission"}),"\neffect cell can be defined in a factory function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Cell Factory Function"',children:"final (ActionCell, ValueCell<bool>) submissionCells(ValueCell<bool> succeed) {\n  final submit = ActionCell();\n\n  final submission = submit.effect(() async {\n    final result = succeed();\n    \n    return await Future.delayed(Duration(seconds: 3), () => result);\n  });\n  \n  return (submit, submission);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"submissionCells"})," function creates the ",(0,i.jsx)(n.code,{children:"submit"})," and ",(0,i.jsx)(n.code,{children:"submission"}),"\ncells and returns them in a record containing the action cell in the\nfirst element, and the effect cell in the second element. The factory\nfunction can then be used in the widget build method as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"@override\nWidget build(BuildContext context) {\n  final succeed = MutableCell(true);\n  \n  final (submit, submission) = submissionCells(succeed);\n  \n  ...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The significance of this is that the code defining the cells is now\nmoved out of the widget body, and can be reused throughout the app."}),"\n",(0,i.jsx)(n.p,{children:"For more than two related cells, it is better to opt for a more\nstructured return type such as class that holds all the related cells:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"@immutable\nclass Submission {\n  final ActionCell action;\n  final ValueCell<bool> result;\n    \n  factory Submission(ValueCell<bool> succeed) {\n    final submit = ActionCell();\n\n    final submission = submit.effect(() async {\n      final result = succeed();\n    \n      return await Future.delayed(Duration(seconds: 3), () => result);\n    });\n  \n    return Submission._internal(\n      action: submit,\n      result: submission\n    );\n  }\n    \n  const Submission._internal({\n    this.action,\n    this.result\n  });\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"@immutable"})," annotation is not required but is recommended so that\na warning is emitted if you end up storing state directly in the\n",(0,i.jsx)(n.code,{children:"Submission"})," class rather than inside the cells."]})}),"\n",(0,i.jsx)(n.p,{children:"This class can then be used in the build method as follows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"@override\nWidget build(BuildContext context) {\n  final succeed = MutableCell(true);\n  final submission = Submission(succeed);\n  ...\n}\n"})}),"\n",(0,i.jsx)(n.h2,{id:"why-use-effect-cells",children:"Why use Effect Cells?"}),"\n",(0,i.jsx)(n.p,{children:"You may be wondering what's the value in using effect cells, when you\ncan achieve the same result without them? The main benefit of using an\neffect cell is that the result / status of the effect, in this case a\n(simulated) form submission, can be observed just like any cell. It\ncan be used in a computed cell / watch function or bound to a widget\nproperty. The alternative would be to manually synchronize the state\nof the side effect with the state of your widgets."}),"\n",(0,i.jsx)(n.p,{children:"For example you would need to do something similar to the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final isLoading = MutableCell(false);\n\nElevatedButton(\n    onPressed isLoading() ? null : () async {\n        isLoading.value = true;\n        await submitForm();\n        isLoading.value = false;\n    }\n    \n    child: isLoading()\n      ? CircularProgressIndicator()\n      : Text('Submit')\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This leaves room for bugs. If, for example, ",(0,i.jsx)(n.code,{children:"submitForm()"})," throws an\nexception, ",(0,i.jsx)(n.code,{children:"isLoading"})," will not be reset to false, which means your UI\nwill now be stuck in the loading state and your user will not be able\nto retry the request. Using effect cells helps to eliminate bugs such\nas these, which are caused when the state of your UI is not properly\nsynchronized with the state of the side effect."]}),"\n",(0,i.jsx)(n.p,{children:"Of course this doesn't mean you should rush to use effect cells\neverywhere. If effect cells don't make sense for your specific case,\nthen don't use them."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var i=t(6540);const s={},l=i.createContext(s);function c(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);