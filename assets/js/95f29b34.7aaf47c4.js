"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[269],{9357:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>d});var t=s(4848),i=s(8453);const l={title:"User Defined Types",description:"Extending cells with accessors for your own classes",sidebar_position:8},r="User Defined Types",a={id:"basics/user-defined-types",title:"User Defined Types",description:"Extending cells with accessors for your own classes",source:"@site/docs/basics/user-defined-types.md",sourceDirName:"basics",slug:"/basics/user-defined-types",permalink:"/live_cells/docs/basics/user-defined-types",draft:!1,unlisted:!1,editUrl:"https://github.com/alex-gutev/live_cells/docs/basics/user-defined-types.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"User Defined Types",description:"Extending cells with accessors for your own classes",sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"State Restoration",permalink:"/live_cells/docs/basics/state-restoration"},next:{title:"Lists, Maps and Sets",permalink:"/live_cells/docs/basics/lists-maps-sets"}},o={},d=[{value:"Live Cell Extension",id:"live-cell-extension",level:2},{value:"Generating the Code",id:"generating-the-code",level:3},{value:"Binding to Properties",id:"binding-to-properties",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"user-defined-types",children:"User Defined Types"}),"\n",(0,t.jsxs)(n.p,{children:["So far we've used cells holding strings and numbers, and an\n",(0,t.jsx)(n.code,{children:"enum"}),". What about types defined by your own classes?"]}),"\n",(0,t.jsxs)(n.p,{children:["A cell can generally hold a value of any type, as long as ",(0,t.jsx)(n.code,{children:"=="})," is\nsuitably defined."]}),"\n",(0,t.jsx)(n.h2,{id:"live-cell-extension",children:"Live Cell Extension"}),"\n",(0,t.jsxs)(n.p,{children:["The\n",(0,t.jsx)(n.a,{href:"https://pub.dev/packages/live_cell_extension",children:(0,t.jsx)(n.code,{children:"live_cell_extension"})}),"\npackage provides a source code generator that allows you to extend the\ncore cell interfaces, ",(0,t.jsx)(n.code,{children:"ValueCell"})," and ",(0,t.jsx)(n.code,{children:"MutableCell"}),", with accessors\nfor properties of your own classes."]}),"\n",(0,t.jsx)(n.p,{children:"To understand what this means, consider the following class:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Person class"',children:"class Person {\n    final String firstName;\n    final String lastName;\n    final int age;\n    \n    const Person({\n        required this.firstName,\n        required this.lastName,\n        required this.age\n    });\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Let's say you have a cell holding a ",(0,t.jsx)(n.code,{children:"Person"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Person cell"',children:"final person = MutableCell(\n    Person(\n        firstName: 'John',\n        lastName: 'Smith',\n        age: 25\n    )\n);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To access a property of the ",(0,t.jsx)(n.code,{children:"Person"})," held in the cell, you will need\nto defined a computed cell:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Accessing properties in cells"',children:"final firstName = ValueCell.computed(() => person().firstName);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If you want the ",(0,t.jsx)(n.code,{children:"firstName"})," cell to be settable, so that setting the\nvalue of ",(0,t.jsx)(n.code,{children:"firstName"})," updates the ",(0,t.jsx)(n.code,{children:"person"})," cell, you'll need to define\na ",(0,t.jsx)(n.code,{children:"copyWith"})," method and a mutable computed cell:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Mutating properties in cells"',children:"final firstName = MutableCell.computed(() => person().firstName, (name) {\n    person.value = person.value.copyWith(\n        firstName: name\n    );\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is the definition of boilerplate and will quickly become tiring."}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"live_cell_extension"})," package automatically generates this code\nfor you, so that instead of the above, you can write the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Generated ValueCell property accessors"',children:"final firstName = person.firstName;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["And to update the value of the ",(0,t.jsx)(n.code,{children:"firstName"})," property:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Generated MutableCell property accessors"',children:"person.firstName.value = 'Jane';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["That's it, no need to write a ",(0,t.jsx)(n.code,{children:"copyWith"})," method either. This ties in\nwith Live Cell's design principle that cells should be\nindistinguishable, as much as is possible, from the values they hold."]}),"\n",(0,t.jsx)(n.h3,{id:"generating-the-code",children:"Generating the Code"}),"\n",(0,t.jsxs)(n.p,{children:["To make this work you'll need to add the ",(0,t.jsx)(n.code,{children:"live_cell_extension"})," package\nto the ",(0,t.jsx)(n.code,{children:"dev_dependencies"})," of your ",(0,t.jsx)(n.code,{children:"pubspec.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"dev_dependencies:\n    live_cell_extension: 0.4.3\n    ...\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then annotate the classes, for which you want accessors to be\ngenerated, with ",(0,t.jsx)(n.code,{children:"CellExtension"}),". If you want mutable cell accessors to\nalso be generated, add ",(0,t.jsx)(n.code,{children:"mutable: true"})," to the annotation arguments."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="person.dart"',children:"part 'person.g.dart';\n\n@CellExtension(mutable: true)\nclass Person {\n    final String firstName;\n    final String lastName;\n    final int age;\n    \n    const Person({\n        required this.firstName,\n        required this.lastName,\n        required this.age\n    });\n}\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["Don't forget to include the ",(0,t.jsx)(n.code,{children:"<filename>.g.dart"})," file. This is where\nthe code will be generated."]})}),"\n",(0,t.jsx)(n.p,{children:"Next you'll need to run the following command in the root directory of\nyour project:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:"dart run build_runner build\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This will generate the ",(0,t.jsx)(n.code,{children:".g.dart"})," files, which contain the generated\nclass property accessors."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"ValueCell"})," accessors are defined in an extension with the name of\nthe class followed by ",(0,t.jsx)(n.code,{children:"CellExtension"}),". The ",(0,t.jsx)(n.code,{children:"MutableCell"})," accessors are\ndefined in an extension with the name of the class followed by\n",(0,t.jsx)(n.code,{children:"MutableCellExtension"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"binding-to-properties",children:"Binding to Properties"}),"\n",(0,t.jsx)(n.p,{children:"Using the generated property accessors, we can define a form for\npopulating the class properties simply by binding the property cells,\nretrieved using the generated accessors, to the appropriate widgets."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Binding directly to properties"',children:"Widget personForm(MutableCell<Person> person) => Column(\n    children: [\n        Text('First Name:'),\n        CellTextField(\n            content: person.firstName\n        ),\n        Text('Last Name:'),\n        CellTextField(\n            content: person.lastName\n        ),\n        Text('Age:'),\n        Numberfield(person.age)\n    ]\n)\n"})}),"\n",(0,t.jsxs)(n.p,{children:["We used the ",(0,t.jsx)(n.code,{children:"Numberfield"})," widget, defined ",(0,t.jsx)(n.a,{href:"error-handling",children:"earlier"}),", for the ",(0,t.jsx)(n.code,{children:"age"}),"\nproperty."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["We defined the form as a function, rather than a widget class since it\nwill only be used within a ",(0,t.jsx)(n.code,{children:"StaticWidget"}),"."]})}),"\n",(0,t.jsx)(n.p,{children:"We can then use this form as follows:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"StaticWidget.builder((_) {\n  final person = MutableCell(\n      Person(\n          firstName: 'John',\n          lastName: 'Smith',\n          age: 25\n      )\n  );\n    \n  return Column(\n    children: [\n      personForm(person),\n      CellText(\n        data: ValueCell.computed(\n          () => '${person.firstName()} ${person.lastName()}: ${person.age()} years'\n        )\n      ),\n      ElevatedButton(\n        child: Text('Save'),\n        // A hypothetical savePerson function\n        onPressed: () => savePerson(person.value)\n      ),\n      ElevatedButton(\n        child: Text('Reset'),\n        onPressed: () => person.value = Person(\n          firstName: 'John',\n          lastName: 'Smith',\n          age: 25\n        )\n      )\n    ]\n  );\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example we used the ",(0,t.jsx)(n.code,{children:"personForm"})," widget defined earlier."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The details of the person are displayed in a ",(0,t.jsx)(n.code,{children:"CellText"}),", which is\nautomatically updated when the person's details are changed."]}),"\n",(0,t.jsxs)(n.li,{children:['The "Save" button saves the entered details, which are held in the\n',(0,t.jsx)(n.code,{children:"person"})," cell."]}),"\n",(0,t.jsxs)(n.li,{children:['The "Reset" button resets the form fields to their defaults by\ndirectly assigning a default ',(0,t.jsx)(n.code,{children:"Person"})," to the ",(0,t.jsx)(n.code,{children:"person"})," cell."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The benefits of this, as opposed to using the tools already available\nin Flutter, are:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"No need to write event handlers and state synchronization code for\nacquiring input from the user. This is all handled automatically."}),"\n",(0,t.jsxs)(n.li,{children:["You can focus directly on the representation of your data and think\nin terms of your data, rather than thinking in terms of widget ",(0,t.jsx)(n.code,{children:"State"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Your widgets are bound directly to your data and kept in sync. There\nis no chance of you accidentally forgetting to synchronize them with\nyour data and vice versa, which eliminates a whole class of bugs."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>r,x:()=>a});var t=s(6540);const i={},l=t.createContext(i);function r(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);