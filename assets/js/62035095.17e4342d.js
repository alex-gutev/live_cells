"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[809],{7358:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>d,toc:()=>r});var l=t(4848),i=t(8453);const a={title:"Two-way Data Flow",description:"Introduction on bi-directional data flow",sidebar_position:5},s="Two-Way Data Flow",d={id:"basics/two-way-data-flow",title:"Two-way Data Flow",description:"Introduction on bi-directional data flow",source:"@site/docs/basics/two-way-data-flow.md",sourceDirName:"basics",slug:"/basics/two-way-data-flow",permalink:"/docs/basics/two-way-data-flow",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Two-way Data Flow",description:"Introduction on bi-directional data flow",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Live Cell Widgets",permalink:"/docs/basics/live-cell-widgets"},next:{title:"Error Handling",permalink:"/docs/basics/error-handling"}},o={},r=[{value:"Mutable Computed Cells",id:"mutable-computed-cells",level:2},{value:"Fun with Mutable Computed Cells",id:"fun-with-mutable-computed-cells",level:2}];function c(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.h1,{id:"two-way-data-flow",children:"Two-Way Data Flow"}),"\n",(0,l.jsx)(n.p,{children:"In all the examples we've seen till this point, data always flows in a\nsingle direction. Now we'll introduce two-way data flow which allows\ndata to flow in both directions between a pair of cells."}),"\n",(0,l.jsx)(n.h2,{id:"mutable-computed-cells",children:"Mutable Computed Cells"}),"\n",(0,l.jsxs)(n.p,{children:["A ",(0,l.jsx)(n.em,{children:"Mutable computed cell"})," is a cell which ordinarily functions like a\nnormal computed cell, created with ",(0,l.jsx)(n.code,{children:"ValueCell.computed"}),", but can also\nhave its value changed by setting its ",(0,l.jsx)(n.code,{children:"value"})," property as though it is\na ",(0,l.jsx)(n.code,{children:"MutableCell"}),". When the value of a mutable computed cell is set, it\n",(0,l.jsx)(n.em,{children:"reverses"})," the computation by setting the argument cells to a value\nsuch that when the mutable computed cell is recomputed, the same value\nwill be produced as the value that was set. Thus mutable computed\ncells support two-way data flow, which is what sets ",(0,l.jsx)(n.strong,{children:"Live Cells"}),"\napart from other reactive state management libraries."]}),"\n",(0,l.jsxs)(n.p,{children:["Mutable computed cells are created using ",(0,l.jsx)(n.code,{children:"MutableCell.computed"}),", which\ntakes the computation function and reverse computation function. The\ncomputation function computes the cell's value as a function of\nargument cells, like ",(0,l.jsx)(n.code,{children:"ValueCell.computed"}),". The reverse computation\nfunction ",(0,l.jsx)(n.em,{children:"reverses"})," the computation by assigning a value to the\nargument cells. It is given the value that was assigned to the ",(0,l.jsx)(n.code,{children:"value"}),"\nproperty."]}),"\n",(0,l.jsx)(n.p,{children:"Example:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Mutable computed cell example"',children:"final a = MutableCell<num>(0);\n\nfinal strA = MutableCell.computed(() => a().toString(), (value) {\n  a.value = num.tryParse(value) ?? 0;\n});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The mutable computed cell ",(0,l.jsx)(n.code,{children:"strA"})," converts the value of its argument\ncell ",(0,l.jsx)(n.code,{children:"a"})," to a string. When the value of ",(0,l.jsx)(n.code,{children:"strA"})," is set:"]}),"\n",(0,l.jsxs)(n.ol,{children:["\n",(0,l.jsxs)(n.li,{children:["A ",(0,l.jsx)(n.code,{children:"num"})," is parsed from the value."]}),"\n",(0,l.jsxs)(n.li,{children:["The value of ",(0,l.jsx)(n.code,{children:"a"})," is set to the parsed ",(0,l.jsx)(n.code,{children:"num"})," value."]}),"\n"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:'language-title="Mutable',metastring:'computed cell"',children:"strA.value = '100';\nprint(a.value + 1); // Prints: 101\n"})}),"\n",(0,l.jsxs)(n.p,{children:["This definition will prove useful when implementing a text field for\nnumeric input. In-fact, this library already provides a definition for\nthis cell with the ",(0,l.jsx)(n.code,{children:"mutableString"})," extension method on ",(0,l.jsx)(n.code,{children:"MutableCell"}),"'s\nholding ",(0,l.jsx)(n.code,{children:"int"}),", ",(0,l.jsx)(n.code,{children:"double"})," and ",(0,l.jsx)(n.code,{children:"num"})," values."]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Example of mutableString()"',children:"final a = MutableCell<num>(0);\nfinal strA = a.mutableString();\n"})}),"\n",(0,l.jsxs)(n.p,{children:["Implementing a text field for numeric input is as simple as binding\nthe ",(0,l.jsx)(n.code,{children:"mutableString"})," cell to the ",(0,l.jsx)(n.em,{children:"content"})," property of a\n",(0,l.jsx)(n.code,{children:"LiveTextField"}),":"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Text field for numeric input"',children:"CellWidget.builder((_) {\n  final a = MutableCell<num>(0);\n  final square = a * a;\n    \n  return Column(\n    children: [\n      LiveTextField(\n        content: a.mutableString()\n        keyboardType: TextInputType.number\n      ),\n      Text('${a()}^2 = ${square()}')\n    ]\n  );\n});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["An integer is parsed from the ",(0,l.jsx)(n.code,{children:"LiveTextField"}),", it's square is computed\nand displayed in a ",(0,l.jsx)(n.code,{children:"Text"})," below it."]}),"\n",(0,l.jsx)(n.admonition,{type:"info",children:(0,l.jsxs)(n.p,{children:["An explicit generic type parameter is given to ",(0,l.jsx)(n.code,{children:"MutableCell"})," to allow\nit to store all numeric values, not just integers, which is the\ndeduced type of its initial value ",(0,l.jsx)(n.code,{children:"0"}),"."]})}),"\n",(0,l.jsx)(n.p,{children:'Here\'s a larger example containing two text fields for numeric input,\na widget that displays the sum of the two numbers entered and a\n"Reset" button:'}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Text field for numeric input"',children:"CellWidget.builder((_) {\n  final a = MutableCell<num>(0);\n  final b = MutableCell<num>(0);\n    \n  final sum = a + b;\n    \n  return Column(\n    children: [\n      Row(\n        children: [\n          LiveTextField(\n            content: a.mutableString(),\n            keyboardType: TextInputType.number\n          ),\n          SizedBox(width: 5),\n          Text('+'),\n          SizedBox(width: 5),\n          LiveTextField(\n            content: b.mutableString(),\n            keyboardType: TextInputType.number\n          ),\n        ],\n      ),\n      Text('${a()} + ${b()} = ${sum()}'),\n      ElevatedButton(\n        child: Text('Reset'),\n        onPressed: () => MutableCell.batch(() {\n          a.value = 0;\n          b.value = 0;\n        })\n      )\n    ]\n  );\n});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["In this example two ",(0,l.jsx)(n.code,{children:"LiveTextField"}),"s are defined with their content\ncells bound to the ",(0,l.jsx)(n.code,{children:"mutableString()"})," of cells ",(0,l.jsx)(n.code,{children:"a"})," and ",(0,l.jsx)(n.code,{children:"b"}),",\nrespectively. This allows us to handle the input provided in the\nfields as numbers rather than strings."]}),"\n",(0,l.jsxs)(n.p,{children:["The ",(0,l.jsx)(n.code,{children:"sum"})," computed cell, defined by a cell expression, computes the\nsum of ",(0,l.jsx)(n.code,{children:"a"})," and ",(0,l.jsx)(n.code,{children:"b"}),". The values of cells ",(0,l.jsx)(n.code,{children:"a"}),", ",(0,l.jsx)(n.code,{children:"b"})," and ",(0,l.jsx)(n.code,{children:"sum"})," are\ndisplayed in a ",(0,l.jsx)(n.code,{children:"Text"})," below the fields."]}),"\n",(0,l.jsxs)(n.p,{children:['The "Reset" button resets both fields by setting the value of ',(0,l.jsx)(n.code,{children:"a"})," and\n",(0,l.jsx)(n.code,{children:"b"})," to ",(0,l.jsx)(n.code,{children:"0"}),". Consequently, this also resets the sum and the value\ndisplayed in the ",(0,l.jsx)(n.code,{children:"Text"}),"."]}),"\n",(0,l.jsx)(n.admonition,{type:"info",children:(0,l.jsxs)(n.p,{children:[(0,l.jsx)(n.code,{children:"MutableCell.batch"})," was used when resetting the fields, in order to\nreset both fields simultaneously."]})}),"\n",(0,l.jsxs)(n.p,{children:["Without mutable computed cells and two-way data flow, this example\nwould require that an ",(0,l.jsx)(n.code,{children:"onChanged"})," event callback is added on the\nfields which does the parsing logic and then updates the values of the\ncells."]}),"\n",(0,l.jsxs)(n.p,{children:["The benefits of using ",(0,l.jsx)(n.code,{children:"LiveTextField"})," and mutable computed cells are:"]}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["No need for a ",(0,l.jsx)(n.code,{children:"TextEditingController"})," which you have to remember to ",(0,l.jsx)(n.code,{children:"dispose"}),"."]}),"\n",(0,l.jsxs)(n.li,{children:["No manual synchronization of state between the ",(0,l.jsx)(n.code,{children:"TextEditingController"})," and the widget ",(0,l.jsx)(n.code,{children:"State"})," /\n",(0,l.jsx)(n.code,{children:"ChangeNotifier"})," object. Your state is instead stored in one place and in one representation."]}),"\n",(0,l.jsxs)(n.li,{children:["No need to use ",(0,l.jsx)(n.code,{children:"StatefulWidget"})," or make ugly empty calls to ",(0,l.jsx)(n.code,{children:"setState(() {})"})," to force the widget\nto update when the ",(0,l.jsx)(n.code,{children:"text"})," property of the ",(0,l.jsx)(n.code,{children:"TextEditingController"})," is updated."]}),"\n"]}),"\n",(0,l.jsx)(n.h2,{id:"fun-with-mutable-computed-cells",children:"Fun with Mutable Computed Cells"}),"\n",(0,l.jsxs)(n.p,{children:["Let's say we want the user to be able to enter the result of the addition and have the values for\n",(0,l.jsx)(n.code,{children:"a"})," and ",(0,l.jsx)(n.code,{children:"b"})," automatically computed and displayed in the corresponding fields:"]}),"\n",(0,l.jsx)(n.p,{children:"We can do this with another mutable computed cell, this time with two arguments:"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Multi-argument mutable computed cell"',children:"final sum = MutableCell.computed(() => a() + b(), (sum) {\n  final half = sum / 2;\n\n  a.value = half;\n  b.value = half;\n});\n"})}),"\n",(0,l.jsxs)(n.p,{children:["The reverse computation function assigns the sum divided by two to\nboth cells ",(0,l.jsx)(n.code,{children:"a"})," and ",(0,l.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,l.jsxs)(n.p,{children:["All that we need to do add this functionality to the previous example,\nis to add a ",(0,l.jsx)(n.code,{children:"LiveTextField"})," and bind its content to the ",(0,l.jsx)(n.code,{children:"sum"})," cell."]}),"\n",(0,l.jsxs)(n.p,{children:["Here's the full example with a ",(0,l.jsx)(n.code,{children:"LiveTextField"})," for the result of the addition:"]}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-dart",metastring:'title="Multi-argument mutable computed cell"',children:"CellWidget.builder((_) {\n  final a = MutableCell<num>(0);\n  final b = MutableCell<num>(0);\n    \n  final sum = MutableCell.computed(() => a() + b(), (sum) {\n    final half = sum / 2;\n    a.value = half;\n    b.value = half;\n  });\n    \n  return Column(\n    children: [\n      Row(\n        children: [\n          LiveTextField(\n            content: a.mutableString(),\n            keyboardType: TextInputType.number\n          ),\n          SizedBox(width: 5),\n          Text('+'),\n          SizedBox(width: 5),\n          LiveTextField(\n            content: b.mutableString(),\n            keyboardType: TextInputType.number\n          ),\n          SizedBox(width: 5),\n          Text('='),\n          SizedBox(width: 5),\n          LiveTextField(\n            content: sum.mutableString(),\n            keyboardType: TextInputType.number\n          )\n        ],\n      )\n    ]\n  );\n});\n"})}),"\n",(0,l.jsxs)(n.ul,{children:["\n",(0,l.jsxs)(n.li,{children:["Entering a value in the fields for ",(0,l.jsx)(n.code,{children:"a"})," and ",(0,l.jsx)(n.code,{children:"b"})," will result in the\n",(0,l.jsx)(n.code,{children:"sum"})," being recomputed and displayed in its field."]}),"\n",(0,l.jsxs)(n.li,{children:["Entering a value in the field for the ",(0,l.jsx)(n.code,{children:"sum"})," results in the values for\n",(0,l.jsx)(n.code,{children:"a"})," and ",(0,l.jsx)(n.code,{children:"b"})," being updated such that their sum equals the value entered."]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>d});var l=t(6540);const i={},a=l.createContext(i);function s(e){const n=l.useContext(a);return l.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),l.createElement(a.Provider,{value:n},e.children)}}}]);