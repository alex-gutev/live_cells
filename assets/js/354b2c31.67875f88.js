"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[800],{2851:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>t,metadata:()=>d,toc:()=>a});var s=l(4848),i=l(8453);const t={title:"Lists, Maps and Sets",description:"Working with cells holding lists, maps and sets",sidebar_position:9},c="Lists, Maps and Sets",d={id:"basics/lists-maps-sets",title:"Lists, Maps and Sets",description:"Working with cells holding lists, maps and sets",source:"@site/docs/basics/lists-maps-sets.md",sourceDirName:"basics",slug:"/basics/lists-maps-sets",permalink:"/docs/basics/lists-maps-sets",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"Lists, Maps and Sets",description:"Working with cells holding lists, maps and sets",sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"User Defined Types",permalink:"/docs/basics/user-defined-types"},next:{title:"Asynchronous Cells",permalink:"/docs/basics/async-cells"}},r={},a=[{value:"Indexing",id:"indexing",level:2},{value:"Iterable Properties",id:"iterable-properties",level:2},{value:"cellList Property",id:"celllist-property",level:2},{value:"Map and Set Properties",id:"map-and-set-properties",level:2}];function o(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"lists-maps-and-sets",children:"Lists, Maps and Sets"}),"\n",(0,s.jsxs)(n.p,{children:["Live Cells provides extensions for cells holding ",(0,s.jsx)(n.code,{children:"List"}),"s, ",(0,s.jsx)(n.code,{children:"Map"}),"s and\n",(0,s.jsx)(n.code,{children:"Set"}),"s, which allow the properties of the ",(0,s.jsx)(n.code,{children:"List"}),", ",(0,s.jsx)(n.code,{children:"Map"})," and ",(0,s.jsx)(n.code,{children:"Set"}),"\ninterfaces to be accessed directly on cells."]}),"\n",(0,s.jsx)(n.h2,{id:"indexing",children:"Indexing"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"[]"})," operator is overloaded for cells holding ",(0,s.jsx)(n.code,{children:"Lists"}),", which\nallows a list element to be retrieved."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="List cell operator[] example"',children:"final list = MutableCell([1, 2, 3, 4]);\nfinal index = MutableCell(0);\n\n/// A cell which accesses the element at `index`\nfinal element = list[index];\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"element"})," cell retrieves the value of the element at ",(0,s.jsx)(n.code,{children:"index"}),"\nwithin ",(0,s.jsx)(n.code,{children:"list"}),". You'll notice that the definition of the ",(0,s.jsx)(n.code,{children:"element"})," cell\nlooks exactly like retrieving the value of an element from an ordinary\n",(0,s.jsx)(n.code,{children:"List"}),". However, unlike an ordinarily ",(0,s.jsx)(n.code,{children:"List"})," element access, ",(0,s.jsx)(n.code,{children:"element"}),"\nis a cell and its value will be recomputed whenever the ",(0,s.jsx)(n.code,{children:"list"})," and\n",(0,s.jsx)(n.code,{children:"index"}),", which is also a cell, change:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="Reactive list element access"',children:"print(element.value); // 1\n\nelement.value = 2;\nprint(element.value); // 3\n\nlist.value = [3, 9, 27];\nprint(element.value); // 27\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"element"})," cell is also a mutable cell which when set, updates the\nvalue of the ",(0,s.jsx)(n.code,{children:"list"})," element at ",(0,s.jsx)(n.code,{children:"index"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="Modifying list through an element access cell"',children:"final list = MutableCell([1, 2, 3, 4]);\nfinal index = MutableCell(0);\n\nfinal element = list[index];\n\nindex.value = 1;\nelement.value = 100;\n\nprint(list); // 1, 100, 3, 4\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["The underlying ",(0,s.jsx)(n.code,{children:"List"})," is not modified but a new ",(0,s.jsx)(n.code,{children:"List"})," is created and\nassigned to the ",(0,s.jsx)(n.code,{children:"list"})," cell."]})}),"\n",(0,s.jsxs)(n.p,{children:["You can also update the ",(0,s.jsx)(n.code,{children:"list"})," element directly using the ",(0,s.jsx)(n.code,{children:"[]="}),"\noperator:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"list[1] = 100;\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["Unlike the ",(0,s.jsx)(n.code,{children:"[]"})," operator, the index provided to the ",(0,s.jsx)(n.code,{children:"[]="})," operator is\na value not a cell."]})}),"\n",(0,s.jsx)(n.h2,{id:"iterable-properties",children:"Iterable Properties"}),"\n",(0,s.jsxs)(n.p,{children:["Cells holding ",(0,s.jsx)(n.code,{children:"Iterable"})," values provide the following properties and\nmethods:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"first"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"last"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"isEmpty"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"isNotEmpty"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"length"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"single"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"toList()"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"toSet()"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Each property/method returns a cell which applies the property\ngetter/method on the ",(0,s.jsx)(n.code,{children:"Iterable"})," held in the cell. This allows you, for\nexample, to retrieve the first value in an ",(0,s.jsx)(n.code,{children:"Iterable"}),", be it a ",(0,s.jsx)(n.code,{children:"List"}),",\n",(0,s.jsx)(n.code,{children:"Set"}),", etc., that is held in a cell, using:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"ValueCell<Iterable> seq;\n...\nfinal first = seq.first\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is roughly equivalent to:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final first = ValueCell.computed(() => seq().first);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"celllist-property",children:"cellList Property"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"cellList"})," property, of cells holding ",(0,s.jsx)(n.code,{children:"Lists"}),", returns a cell\nwhich evaluates to an ",(0,s.jsx)(n.code,{children:"Iterable"})," of cells, with each cell accessing\nthe value of an element in the original ",(0,s.jsx)(n.code,{children:"List"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"For example, consider the following cell:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// A list with four elements\nfinal list = MutableCell([1, 2, 3, 4]);\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"list.cellList"})," returns a cell which holds the following list of cells:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final cellList = list.cellList;\n\n// cellList.value is equivalent to the following:\n[list[0], list[1], list[2], list[3]]\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"cellList"})," is reactive, like any other cell, and its value will\nlikewise change whenever the value of ",(0,s.jsx)(n.code,{children:"list"})," changes. However,\n",(0,s.jsx)(n.code,{children:"cellList"})," only reacts to changes in the ",(0,s.jsx)(n.code,{children:"length"})," of the ",(0,s.jsx)(n.code,{children:"list"}),",\ni.e. when the number of elements in the list change, and not the\nvalues of the elements themselves."]}),"\n",(0,s.jsxs)(n.p,{children:["You can test this out using ",(0,s.jsx)(n.code,{children:"ValueCell.watch"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"ValueCell.watch(() {\n    print('${cellList().length} elements');\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The following will not cause ",(0,s.jsx)(n.code,{children:"cellList"})," to be recomputed:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Doesn't print anything since the \n// number of elements hasn't changed\nlist.value = [5, 6, 7, 8];\n\nlist[0] = 100;\nlist[2] = -1;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["However the following will cause ",(0,s.jsx)(n.code,{children:"cellList"})," to be recomputed:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"// Prints: 3 elements\nlist.value = [1, 2, 3]\n\n// Prints: 0 elements\nlist.value = [];\n\n// Prints: 7 elements\nlist.value = [1, 2, 3, 4, 5, 6, 7];\n"})}),"\n",(0,s.jsx)(n.h2,{id:"map-and-set-properties",children:"Map and Set Properties"}),"\n",(0,s.jsxs)(n.p,{children:["The following properties and methods are provided by cells holding\n",(0,s.jsx)(n.code,{children:"Map"})," values:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"entries"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"keys"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"values"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"isEmpty"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"isNotEmpty"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"length"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"containsKey()"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"containsValue()"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Like with cells holding ",(0,s.jsx)(n.code,{children:"List"})," values, these properties and methods\nreturn cells which apply the property getter/method on the ",(0,s.jsx)(n.code,{children:"List"})," held\nin the cell."]}),"\n",(0,s.jsxs)(n.p,{children:["The indexing operator ",(0,s.jsx)(n.code,{children:"[]"})," is also provided, which takes a cell for the key:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final map = MutableCell({\n    'k1': 1,\n    'k2': 2,\n    'k3': 3\n});\n\nfinal key = MutableCell('k1');\nfinal element = map[key];\n\nprint(element.value); // 1\n\nelement.value = 100;\nprint(map.value['k1']); // 100\n\nkey.value = 'k3';\nprint(element.value); // 3\n\nkey.value = 'not in map';\nprint(element.value); // null\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Setting the value of a cell created by ",(0,s.jsx)(n.code,{children:"[]"}),", updates the value of the\nentry in the ",(0,s.jsx)(n.code,{children:"Map"})," cell. Like with cells holding ",(0,s.jsx)(n.code,{children:"List"}),"s, the actual\n",(0,s.jsx)(n.code,{children:"Map"})," instance is not modified, but a new ",(0,s.jsx)(n.code,{children:"Map"}),", with the updated\nentry, is created and assigned to the ",(0,s.jsx)(n.code,{children:"Map"})," cell."]}),"\n",(0,s.jsxs)(n.p,{children:["The following methods are provided by cells holding ",(0,s.jsx)(n.code,{children:"Set"})," values:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"contains"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"containsAll"})}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Both ",(0,s.jsx)(n.code,{children:"contains"})," and ",(0,s.jsx)(n.code,{children:"containsAll"})," return mutable cells, if the ",(0,s.jsx)(n.code,{children:"Set"}),"\ncell on which they are called is mutable. This allows elements to be\nadded and removed from the set with the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final set = MutableCell({1, 2, 3});\nfinal item = MutableCell(4);\n\nfinal contains = set.contains(item);\n\n// Add `4` to the set\ncontains.value = true;\n\n// Remove `4` from the set\ncontains.value = false;\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Given that a ",(0,s.jsx)(n.code,{children:"Set"})," is an ",(0,s.jsx)(n.code,{children:"Iterable"}),", all the properties provided by\ncells holding ",(0,s.jsx)(n.code,{children:"Iterables"})," are also provided by cells holding ",(0,s.jsx)(n.code,{children:"Sets"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>c,x:()=>d});var s=l(6540);const i={},t=s.createContext(i);function c(e){const n=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),s.createElement(t.Provider,{value:n},e.children)}}}]);