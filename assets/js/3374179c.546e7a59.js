"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[180],{3389:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>h,contentTitle:()=>c,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>o});var t=l(4848),s=l(8453);const i={title:"Cells",description:"Introduction to the cell -- the basic building block of Live Cells.",sidebar_position:1},c="Cells",a={id:"basics/cells",title:"Cells",description:"Introduction to the cell -- the basic building block of Live Cells.",source:"@site/docs/basics/cells.md",sourceDirName:"basics",slug:"/basics/cells",permalink:"/docs/basics/cells",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Cells",description:"Introduction to the cell -- the basic building block of Live Cells.",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Basics",permalink:"/docs/category/basics"},next:{title:"Cells in Widgets",permalink:"/docs/basics/cell-widgets"}},h={},o=[{value:"Mutable Cells",id:"mutable-cells",level:2},{value:"Observing Cells",id:"observing-cells",level:2},{value:"Computed Cells",id:"computed-cells",level:2},{value:"Lightweight Computed Cells",id:"lightweight-computed-cells",level:2},{value:"Batch Updates",id:"batch-updates",level:2}];function r(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"cells",children:"Cells"}),"\n",(0,t.jsxs)(n.p,{children:["A cell, denoted by the base type ",(0,t.jsx)(n.code,{children:"ValueCell"}),", is an object with a\nvalue and a set of observers that react to changes in its value."]}),"\n",(0,t.jsxs)(n.p,{children:["The simplest cell is the constant cell which holds a constant\nvalue. These are created with the ",(0,t.jsx)(n.code,{children:".cell"})," property, added to all\nobjects, or the ",(0,t.jsx)(n.code,{children:"ValueCell.value"})," constructor."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Constant cells"',children:"final a = 1.cell;\nfinal b = 'hello world'.cell;\nfinal c = ValueCell.value(someValue);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The value of a cell is accessed using the ",(0,t.jsx)(n.code,{children:"value"})," property."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Accessing cell values"',children:"print(a.value); // Prints: 1\nprint(b.value); // Prints: 'hello world'\nprint(c.value); // Prints the value of `someValue`\n"})}),"\n",(0,t.jsx)(n.h2,{id:"mutable-cells",children:"Mutable Cells"}),"\n",(0,t.jsxs)(n.p,{children:["Mutable cells, created with the ",(0,t.jsx)(n.code,{children:"MutableCell"})," constructor, hold a\nvalue that can be set directly, by assigning a value to the ",(0,t.jsx)(n.code,{children:"value"}),"\nproperty."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Creating mutable cells"',children:"final a = MutableCell(0);\n\nprint(a.value); // Prints: 0\n\na.value = 3;\nprint(a.value); // Prints: 3\n"})}),"\n",(0,t.jsx)(n.h2,{id:"observing-cells",children:"Observing Cells"}),"\n",(0,t.jsxs)(n.p,{children:["When the value of a cell changes, its observers are notified of the\nchange. The simplest way to demonstrate this is to set up a ",(0,t.jsx)(n.em,{children:"watch\nfunction"})," using ",(0,t.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ValueCell/watch.html",children:(0,t.jsx)(n.code,{children:"ValueCell.watch"})}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Observing cells"',children:"final a = MutableCell(0);\nfinal b = MutableCell(1);\n\n// Set up a watch function observing cells `a` and `b`\nfinal watcher = ValueCell.watch(() {\n    print('${a()} + ${b()} = ${a() + b()}');\n});\n\na.value = 5;  // Prints: 5 + 1 = 6\nb.value = 10; // Prints: 5 + 10 = 15\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, a watch function that prints the values of cells\n",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," to the console, along with their sum, is defined. This\nfunction is called automatically when the value of either ",(0,t.jsx)(n.code,{children:"a"})," or ",(0,t.jsx)(n.code,{children:"b"}),"\nchanges."]}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsx)(n.p,{children:"Within watch functions, the value of a cell is referenced using the\nfunction call operator rather than accessing the value property\ndirectly."})}),"\n",(0,t.jsxs)(n.p,{children:["There are a couple of important points to keep in mind when using\n",(0,t.jsx)(n.code,{children:"ValueCell.watch"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The watch function is called once immediately when ",(0,t.jsx)(n.code,{children:"ValueCell.watch"}),"\nis called, to determine which cells are referenced within it."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"ValueCell.watch"})," automatically tracks which cells are referenced\nwithin the watch function, and registers it to be called when the\nvalues of the referenced cells change. This works even when the\ncells are referenced conditionally."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Within the watch function, the values of cells have to be referenced\nwith the function call operator rather than the ",(0,t.jsx)(n.code,{children:"value"}),"\nproperty. The difference between the two is that ",(0,t.jsx)(n.code,{children:".value"})," only\nreferences the value, whereas the function call operator also tracks\nthe cell as a referenced cell."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Every call to ",(0,t.jsx)(n.code,{children:"ValueCell.watch"})," adds a new watch function, for\nexample:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Multiple watch functions"',children:"final watcher2 = ValueCell.watch(() => print('A = ${a()}'));\n\n// Prints: 20 + 10 = 30\n// Also prints: A = 20\na.value = 20;\n\n// Prints: 20 + 1 = 21\nb.value = 1;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The watch function defined above, ",(0,t.jsx)(n.code,{children:"watcher2"}),", observes the value of\n",(0,t.jsx)(n.code,{children:"a"})," only. Changing the value of ",(0,t.jsx)(n.code,{children:"a"})," results in both watch functions\nbeing called. Changing the value of ",(0,t.jsx)(n.code,{children:"b"})," only results in the first\nwatch function being called, since the second watch function is not\nobserving ",(0,t.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["When you no longer need the watch function to be called, call\n",(0,t.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/CellWatcher/stop.html",children:(0,t.jsx)(n.code,{children:"stop"})}),"\non the ",(0,t.jsx)(n.code,{children:"CellWatcher"})," object returned by ",(0,t.jsx)(n.code,{children:"ValueCell.watch"}),"."]})}),"\n",(0,t.jsxs)(n.p,{children:["The\n",(0,t.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/Watch/Watch.html",children:(0,t.jsx)(n.code,{children:"Watch"})}),"\nconstructor allows you to define a watch function which has access to\nits own handle. This allows you to define a watch function that can be\nstopped from within the function itself:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final a = MutableCell(0);\n\nWatch((handle) {\n    print('A = ${a()}')\n    \n    if (a() > 10) {\n        handle.stop();\n    }\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example a watch function is defined that prints the value of\ncell ",(0,t.jsx)(n.code,{children:"a"})," to the console. When the value of ",(0,t.jsx)(n.code,{children:"a"})," exceeds 10 the watch\nfunction is stopped, by calling ",(0,t.jsx)(n.code,{children:"stop()"})," on the handle provided to the\nwatch function."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"a.value = 1;  // Prints: A = 1\na.value = 5;  // Prints: A = 5\na.value = 11; // Prints: A = 11\n\n// The watch function is stopped at this point\n\na.value = 7; // Doesn't print anything\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.em,{children:"handle"})," also provides an\n",(0,t.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/CellWatcher/afterInit.html",children:(0,t.jsx)(n.code,{children:"afterInit()"})}),'\nmethod, which exits the watch function when it is called during the\nfirst call to the watch function. This is useful when you don\'t want\nthe side effects defined in the watch function to run on the initial\n"setup" call.']}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"Watch((handle) {\n    final value = a();\n    \n    handle.afterInit();\n    \n    print('A = ${a()}');\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example the value of ",(0,t.jsx)(n.code,{children:"a"})," is only printed when it changes\n",(0,t.jsx)(n.strong,{children:"after"})," the watch function is defined with ",(0,t.jsx)(n.code,{children:"Watch"}),". It is not\nprinted when the watch function is called for the first time to\ndetermine its dependencies."]}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsxs)(n.p,{children:["The watch function must observe at least one cell, using the function\ncall operator, before the ",(0,t.jsx)(n.code,{children:"afterInit()"})," call. Otherwise, the watch\nfunction will not be observing any cells and will never be called."]})}),"\n",(0,t.jsx)(n.h2,{id:"computed-cells",children:"Computed Cells"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.em,{children:"computed cell"}),", defined using ",(0,t.jsx)(n.code,{children:"ValueCell.computed"}),", is a cell\nwith a value that is defined as a function of the values of one or\nmore argument cells. Whenever the value of an argument cell changes,\nthe value of the computed cell is recomputed."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Computed cells"',children:"final a = MutableCell(1);\nfinal b = MutableCell(2);\nfinal sum = ValueCell.computed(() => a() + b());\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the above example, ",(0,t.jsx)(n.code,{children:"sum"})," is a computed cell with its value defined\nas the sum of cells ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"}),". The value of ",(0,t.jsx)(n.code,{children:"sum"})," is recomputed\nwhenever the value of either ",(0,t.jsx)(n.code,{children:"a"})," or ",(0,t.jsx)(n.code,{children:"b"})," changes. This is demonstrated\nbelow:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Computed cells"',children:"final watcher = ValueCell.watch(() {\n    print('The sum is ${sum()}');\n});\n\na.value = 3; // Prints: The sum is 5\nb.value = 4; // Prints: The sum is 7\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this example:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["A watch function observing the ",(0,t.jsx)(n.code,{children:"sum"})," cell is defined."]}),"\n",(0,t.jsxs)(n.li,{children:["The value of ",(0,t.jsx)(n.code,{children:"a"})," is set to ",(0,t.jsx)(n.code,{children:"3"}),", which:","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Causes the value of ",(0,t.jsx)(n.code,{children:"sum"})," to be recomputed"]}),"\n",(0,t.jsx)(n.li,{children:"Calls the watch function defined in 1."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["The value of ",(0,t.jsx)(n.code,{children:"b"})," is set to ",(0,t.jsx)(n.code,{children:"4"}),", which likewise also results in the\nsum being recomputed and the watch function being called."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By default, computed cells notify their observers whenever their value\nis recomputed, which happens when the value of at least one of the\nreferenced argument cells changes. This means that even if the new\nvalue of the computed cell is equal to its previous value, the\nobservers of the cell are still notified that the cell's value has\nchanged."}),"\n",(0,t.jsxs)(n.p,{children:["By providing ",(0,t.jsx)(n.code,{children:"changesOnly: true"})," to ",(0,t.jsx)(n.code,{children:"ValueCell.computed"}),", the computed\ncell will not notify its observers if its new value is equal, by ",(0,t.jsx)(n.code,{children:"=="}),",\nto its previous value."]}),"\n",(0,t.jsx)(n.p,{children:"This is demonstrated with the following example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final a = MutableCell(0);\nfinal b = ValueCell.computed(() => a() % 2, changeOnly: true);\n\nValueCell.watch(() => print('${b()}'));\n\na.value = 1;\na.value = 3;\na.value = 5;\na.value = 6;\na.value = 8;\n"})}),"\n",(0,t.jsx)(n.p,{children:"This results in the following being printed to the console:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"0\n1\n0\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice only three lines are printed to the console even though the\nvalue of the computed cell argument ",(0,t.jsx)(n.code,{children:"a"})," was changed five times."]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"changesOnly: true"})," is omitted from the definition of ",(0,t.jsx)(n.code,{children:"b"}),", the\nfollowing is printed to the console:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"0\n1\n1\n1\n0\n0\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that a new line is printed to the console whenever the value of\n",(0,t.jsx)(n.code,{children:"a"}),", which is an argument of ",(0,t.jsx)(n.code,{children:"b"}),", is changed. This is because ",(0,t.jsx)(n.code,{children:"b"}),"\nnotifies its observers whenever the value of its argument ",(0,t.jsx)(n.code,{children:"a"})," has\nchanged even when ",(0,t.jsx)(n.code,{children:"b"}),"'s new value is equal to its previous value."]}),"\n",(0,t.jsx)(n.admonition,{type:"important",children:(0,t.jsxs)(n.p,{children:["By default computed cells are evaluated lazily. This means the\ncomputation function of a computed cell is not run unless its value is\nactually referenced. However, providing ",(0,t.jsx)(n.code,{children:"changesOnly: true"})," to\n",(0,t.jsx)(n.code,{children:"ValueCell.computed"})," makes the cell eager, which means the\ncomputation function is run regardless of whether the cell's value is\nreferenced or not."]})}),"\n",(0,t.jsx)(n.h2,{id:"lightweight-computed-cells",children:"Lightweight Computed Cells"}),"\n",(0,t.jsxs)(n.p,{children:["Another way to create computed cells is with the\n",(0,t.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ComputeExtension/apply.html",children:(0,t.jsx)(n.code,{children:"apply"})}),"\nextension method on a record containing the arguments of the cell. The\ncomputation function, provided to ",(0,t.jsx)(n.code,{children:"apply"}),", is passed the values of the\nargument cells that are listed in the record on which ",(0,t.jsx)(n.code,{children:"apply"})," is\ncalled."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"sum"})," cell from the previous example can also be defined as:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final a = MutableCell(0);\nfinal b = MutableCell(1);\n\nfinal sum = (a, b).apply((a, b) => a + b);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This definition is functionally equivalent to the previous\ndefinition. It computes the same value, which is recomputed whenever\nthe value of either ",(0,t.jsx)(n.code,{children:"a"})," or ",(0,t.jsx)(n.code,{children:"b"})," changes. However this definition is\ndifferent in that:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The argument cells ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," are specified explicitly in the\nrecord on which ",(0,t.jsx)(n.code,{children:"apply"})," is called."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"The argument cells are known at compile-time rather than determined\nat run-time. Thus this definition has less run time overhead."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["The value of the ",(0,t.jsx)(n.code,{children:"sum"})," cell is not cached. Instead it is recomputed\nwhenever the value of the cell is accessed."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["To create a lightweight computed cell taking a single argument, call\n",(0,t.jsx)(n.code,{children:"apply"})," on the argument cell:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final b = a.apply((a) => a + 1);\n"})})]}),"\n",(0,t.jsxs)(n.p,{children:["This definition is more lightweight than the previous definition of\n",(0,t.jsx)(n.code,{children:"sum"}),", since it doesn't have the overhead of determining the cell\narguments at run time or the overhead of caching the cell\nvalue. However it is less convenient since the argument cells have to\nbe listed beforehand, whereas with the previous definition, the\narguments cells are determined automatically."]}),"\n",(0,t.jsxs)(n.p,{children:["For cells consisting of a simple computation, such as the ",(0,t.jsx)(n.code,{children:"sum"})," cell,\nthere is no need to cache the value since the overhead of the caching\nlogic will likely increase the computational time. However, for more\nexpensive value computation functions it may be beneficial to only run\nthe computation function once and cache the result until the values of\nthe argument cells change. The\n",(0,t.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/StoreCellExtension/store.html",children:(0,t.jsx)(n.code,{children:"store()"})}),"\nmethod of ",(0,t.jsx)(n.code,{children:"ValueCell"})," creates a cell that adds caching to another\ncell."]}),"\n",(0,t.jsxs)(n.p,{children:["Caching can be added to the ",(0,t.jsx)(n.code,{children:"sum"})," cell as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final sum = (a, b).apply((a, b) => a + b);\nfinal cached_sum = sum.store();\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The cell ",(0,t.jsx)(n.code,{children:"cached_sum"})," evaluates to the same value as the ",(0,t.jsx)(n.code,{children:"sum"})," cell\nbut caches it until the values of the argument cells ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"}),"\nchange. The best way to demonstrate the difference is to change the\ndefinition of sum to the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final sum = (a, b).apply((a, b) {\n    print('Computing sum');\n    return a + b;\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"The following watch function:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"ValueCell.watch(() {\n    print('a + b = ${sum()}');\n    print('The sum is ${sum()}');\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"Results in the following being printed to the console:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Computing sum\na + b = 1\nComputing sum\nThe sum is 1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that the computation function of ",(0,t.jsx)(n.code,{children:"sum"})," is called whenever the\nvalue of the cell is referenced."]}),"\n",(0,t.jsxs)(n.p,{children:["The following watch function references the value of ",(0,t.jsx)(n.code,{children:"cached_sum"}),",\nwhich caches the value of ",(0,t.jsx)(n.code,{children:"sum"})," using ",(0,t.jsx)(n.code,{children:".store()"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"ValueCell.watch(() {\n    print('a + b = ${cached_sum()}');\n    print('The sum is ${cached_sum()}');\n});\n"})}),"\n",(0,t.jsx)(n.p,{children:"This results in the following being printed to the console:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Computing sum\na + b = 1\nThe sum is 1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Notice that the computation function of ",(0,t.jsx)(n.code,{children:"sum"})," is now called only the\nfirst time the value of ",(0,t.jsx)(n.code,{children:"cached_sum"})," is referenced."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:".store()"})," also accepts a ",(0,t.jsx)(n.code,{children:"changesOnly"})," argument like\n",(0,t.jsx)(n.code,{children:"ValueCell.computed"}),". When given ",(0,t.jsx)(n.code,{children:"changesOnly: true"}),", the cell\nreturned by ",(0,t.jsx)(n.code,{children:".store()"})," only notifies its observers when the new value\nof the argument cell is not equal to its previous value."]}),"\n",(0,t.jsx)(n.p,{children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",children:"final cached_sum = sum.store(changesOnly: true);\n"})}),"\n",(0,t.jsx)(n.h2,{id:"batch-updates",children:"Batch Updates"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"MutableCell.batch"})," function allows the values of multiple mutable\ncells to be set simultaneously. The effect of this is that while the\nvalues of the cells are changed as soon as their ",(0,t.jsx)(n.code,{children:"value"})," properties\nare set, the observers of the cells are only notified after all the\ncell values have been set."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-dart",metastring:'title="Batch updates"',children:"final a = MutableCell(0);\nfinal b = MutableCell(1);\n\nfinal watcher = ValueCell.watch(() {\n    print('a = ${a()}, b = ${b()}');\n});\n\n// This only prints: a = 15, b = 3\nMutableCell.batch(() {\n    a.value = 15;\n    b.value = 3;\n});\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In the example above, the values of ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," are set to ",(0,t.jsx)(n.code,{children:"15"})," and\n",(0,t.jsx)(n.code,{children:"3"})," respectively, within ",(0,t.jsx)(n.code,{children:"MutableCell.batch"}),". The watch function,\nwhich observes both ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"}),", is only called once after the values\nof both ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," are set."]}),"\n",(0,t.jsx)(n.p,{children:"As a result the following is printed to the console:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"a = 0, b = 1\na = 15, b = 3\n"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a = 0, b = 1"})," is printed when the watch function is first defined."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a = 15, b = 3"})," is printed when ",(0,t.jsx)(n.code,{children:"MutableCell.batch"})," returns."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"A watch function is always called once immediately after it is set\nup. This is necessary to determine, which cells the watch function is\nobserving."})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>c,x:()=>a});var t=l(6540);const s={},i=t.createContext(s);function c(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);