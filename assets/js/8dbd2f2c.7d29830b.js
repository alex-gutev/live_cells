"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[216],{6002:(e,l,n)=>{n.r(l),n.d(l,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>c,toc:()=>d});var s=n(4848),t=n(8453);const i={title:"Cell Keys",description:"What cell keys are and what they are used for.",sidebar_position:1},a="Cell Keys",c={id:"advanced/cell-keys",title:"Cell Keys",description:"What cell keys are and what they are used for.",source:"@site/docs/advanced/cell-keys.md",sourceDirName:"advanced",slug:"/advanced/cell-keys",permalink:"/docs/advanced/cell-keys",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Cell Keys",description:"What cell keys are and what they are used for.",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Advanced",permalink:"/docs/category/advanced"},next:{title:"Lightweight Computed Cells",permalink:"/docs/advanced/lightweight-cells"}},r={},d=[{value:"Keyed cells",id:"keyed-cells",level:2},{value:"Why?",id:"why",level:3},{value:"Which cells have keys?",id:"which-cells-have-keys",level:2},{value:"Keys for your own cells",id:"keys-for-your-own-cells",level:2},{value:"Keys for mutable cells",id:"keys-for-mutable-cells",level:2}];function o(e){const l={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(l.h1,{id:"cell-keys",children:"Cell Keys"}),"\n",(0,s.jsx)(l.p,{children:"We stated a couple of times in the documentation that a certain\nproperty returns a keyed cell. Now we'll explain what that actually\nmeans."}),"\n",(0,s.jsx)(l.h2,{id:"keyed-cells",children:"Keyed cells"}),"\n",(0,s.jsxs)(l.p,{children:["A keyed cell is a cell with a key that identifies the cell. If two\ndistinct ",(0,s.jsx)(l.code,{children:"ValueCell"})," instances have the same key, under ",(0,s.jsx)(l.code,{children:"=="}),", then the\ntwo cells compare ",(0,s.jsx)(l.code,{children:"=="}),". In-effect, this allows them to function as\nthough they are the same cell despite being two separate objects."]}),"\n",(0,s.jsxs)(l.p,{children:["Great, so how's that useful? Consider the following code which creates\na ",(0,s.jsx)(l.code,{children:"CellWidget"})," that observes a cell ",(0,s.jsx)(l.code,{children:"a"}),":"]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",children:"CellWidget.builder((_) {\n    final a = ...;\n    \n    return Text(a());\n});\n"})}),"\n",(0,s.jsxs)(l.p,{children:[(0,s.jsx)(l.code,{children:"a"})," is created in the widget build function, and observed by the\n",(0,s.jsx)(l.code,{children:"CellWidget"}),". When the ",(0,s.jsx)(l.code,{children:"CellWidget"})," is rebuilt, the build function is\ncalled again, a new ",(0,s.jsx)(l.code,{children:"a"})," is created and the ",(0,s.jsx)(l.code,{children:"CellWidget"})," is now\nobserving the new ",(0,s.jsx)(l.code,{children:"a"})," alongside the previous ",(0,s.jsx)(l.code,{children:"a"}),". With every rebuild\nof the ",(0,s.jsx)(l.code,{children:"CellWidget"}),", a new ",(0,s.jsx)(l.code,{children:"a"})," is being observed. Besides leaking\nmemory, the state of ",(0,s.jsx)(l.code,{children:"a"})," is lost and reset on every build."]}),"\n",(0,s.jsxs)(l.p,{children:["Cell keys were created to avoid this problem. If the ",(0,s.jsx)(l.code,{children:"CellWidget"})," is\nrebuilt and a new ",(0,s.jsx)(l.code,{children:"a"})," is created, BUT with the same key as the\nprevious ",(0,s.jsx)(l.code,{children:"a"}),", the ",(0,s.jsx)(l.code,{children:"CellWidget"})," sees it as the same cell and continues\nobserving the previous ",(0,s.jsx)(l.code,{children:"a"}),". More importantly, the new ",(0,s.jsx)(l.code,{children:"a"})," shares the\nsame state (and hence the same value) as the previous ",(0,s.jsx)(l.code,{children:"a"}),". In-effect\nit is the same cell, just referenced by a different object."]}),"\n",(0,s.jsxs)(l.p,{children:["Remember we said ",(0,s.jsx)(l.code,{children:"CellWidget"})," automatically generates a key for cells\ndefined within its build method. That's how the magic works, it's not\nreally magic now is it, and how the state of cells can be persisted\nacross builds. ",(0,s.jsx)(l.code,{children:"CellWidget"})," automatically generates a key for each\ncell defined in its build function/method that does not already have a\nkey."]}),"\n",(0,s.jsx)(l.p,{children:"Keys are not only useful in widgets, but also in computed cells:"}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",children:"final a = MutableCell(0);\nfinal sum = ValueCell.computed(() => a() + a.previous());\n"})}),"\n",(0,s.jsxs)(l.p,{children:["Notice, we directly referenced the ",(0,s.jsx)(l.code,{children:"previous"})," property (which\nreferences the previous value of cell ",(0,s.jsx)(l.code,{children:"a"}),"), in the computed cell. We\nare able to do this because ",(0,s.jsx)(l.code,{children:"previous"})," returns a keyed cell. If it\nweren't for keyed cells we would have to store ",(0,s.jsx)(l.code,{children:"a.previous"}),"\nin a local variable first and reference that in the computed cell,\ni.e. something similar to the following:"]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",children:"final a = MutableCell(0);\nfinal prev = a.previous;\n\nfinal sum = ValueCell.computed(() => a() + prev());\n"})}),"\n",(0,s.jsxs)(l.p,{children:["The second snippet is more verbose and would be inefficient, if\n",(0,s.jsx)(l.code,{children:"previous"})," wasn't a keyed cell, because every ",(0,s.jsx)(l.code,{children:"a.previous"})," would\ncreate a new cell that tracks the previous value of ",(0,s.jsx)(l.code,{children:"a"}),". With keyed\ncells there is only a single ",(0,s.jsx)(l.code,{children:"a.previous"})," cell that is tracking the\nprevious value of ",(0,s.jsx)(l.code,{children:"a"}),"."]}),"\n",(0,s.jsx)(l.h3,{id:"why",children:"Why?"}),"\n",(0,s.jsx)(l.p,{children:"You may be asking why keyed cells instead of just caching the created\ncells in private properties? There's three reasons for this:"}),"\n",(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsx)(l.li,{children:"It keeps the core cell classes small."}),"\n",(0,s.jsxs)(l.li,{children:["All additional functionality ",(0,s.jsx)(l.code,{children:".previous"}),", ",(0,s.jsx)(l.code,{children:".wait"}),", ",(0,s.jsx)(l.code,{children:".delayed"}),",\n",(0,s.jsx)(l.code,{children:".first"}),", ",(0,s.jsx)(l.code,{children:".last"}),", ..., can be kept in extensions on the relevant\n",(0,s.jsx)(l.code,{children:"ValueCell"})," classes rather than bloating the classes themselves."]}),"\n",(0,s.jsxs)(l.li,{children:[(0,s.jsx)(l.code,{children:"live_cell_extension"})," (see ",(0,s.jsx)(l.a,{href:"/docs/basics/user-defined-types",children:"User Defined\nTypes"}),") would not have been\npossible without cell keys."]}),"\n",(0,s.jsxs)(l.li,{children:["This allows users of the library to extend the cell classes with\ntheir own properties, e.g. ",(0,s.jsx)(l.code,{children:".foo"}),", which can be used just like a\nbuilt in property."]}),"\n"]}),"\n",(0,s.jsx)(l.h2,{id:"which-cells-have-keys",children:"Which cells have keys?"}),"\n",(0,s.jsx)(l.p,{children:"The cells returned by cell property getters are always keyed\ncells. This includes (but is not limited to):"}),"\n",(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsxs)(l.li,{children:["\n",(0,s.jsx)(l.p,{children:"List cell extension properties:"}),"\n",(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsx)(l.li,{children:(0,s.jsx)(l.code,{children:".first"})}),"\n",(0,s.jsx)(l.li,{children:(0,s.jsx)(l.code,{children:".last"})}),"\n",(0,s.jsx)(l.li,{children:(0,s.jsx)(l.code,{children:".length"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(l.li,{children:["\n",(0,s.jsx)(l.p,{children:"Map cell extension properties"}),"\n"]}),"\n",(0,s.jsxs)(l.li,{children:["\n",(0,s.jsxs)(l.p,{children:[(0,s.jsx)(l.code,{children:"previous"})," cells"]}),"\n"]}),"\n",(0,s.jsxs)(l.li,{children:["\n",(0,s.jsxs)(l.p,{children:[(0,s.jsx)(l.code,{children:"peek"})," cells"]}),"\n"]}),"\n",(0,s.jsxs)(l.li,{children:["\n",(0,s.jsxs)(l.p,{children:["Cell property accessors generated for classes annotated with\n",(0,s.jsx)(l.code,{children:"@CellExtension"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(l.p,{children:"Also the following cells are keyed:"}),"\n",(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsxs)(l.li,{children:["\n",(0,s.jsx)(l.p,{children:"Constant cells"}),"\n"]}),"\n",(0,s.jsxs)(l.li,{children:["\n",(0,s.jsx)(l.p,{children:"Cells returned by the indexing operator on List and Map cells:"}),"\n",(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsx)(l.li,{children:(0,s.jsx)(l.code,{children:"list[1.cell]"})}),"\n",(0,s.jsx)(l.li,{children:(0,s.jsx)(l.code,{children:"map['key'.cell]"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(l.li,{children:["\n",(0,s.jsxs)(l.p,{children:["Equality comparison cells created with ",(0,s.jsx)(l.code,{children:"eq"})," and ",(0,s.jsx)(l.code,{children:"neq"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(l.p,{children:["To be sure whether a specific method returns a keyed cell or not,\nconsult the ",(0,s.jsx)(l.a,{href:"https://pub.dev/documentation/live_cells/latest/",children:"API\nReference"}),"."]}),"\n",(0,s.jsx)(l.h2,{id:"keys-for-your-own-cells",children:"Keys for your own cells"}),"\n",(0,s.jsxs)(l.p,{children:["You can assign a key to your own computed cells, created with\n",(0,s.jsx)(l.code,{children:"ValueCell.computed"}),", by providing the key in the ",(0,s.jsx)(l.code,{children:"key"})," argument:"]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",metastring:'title="Keyed computed cell"',children:"final cell = ValueCell.computed(() => a() + b(),\n    key: MyKey(a, b)\n);\n"})}),"\n",(0,s.jsxs)(l.p,{children:["Any object which overloads ",(0,s.jsx)(l.code,{children:"=="})," and ",(0,s.jsx)(l.code,{children:"hashCode"})," can serve as a cell\nkey. For your own keys, you're generally encouraged to do the following:"]}),"\n",(0,s.jsxs)(l.ul,{children:["\n",(0,s.jsx)(l.li,{children:"Use a class per key type. For example if you have a function which\nreturns a cell, create a key class that is only used by that\nfunction."}),"\n",(0,s.jsxs)(l.li,{children:["If your cell depends on other cells, include those cells in the key\nclass and in its implementation of ",(0,s.jsx)(l.code,{children:"=="}),"."]}),"\n"]}),"\n",(0,s.jsxs)(l.p,{children:["An example implementation of ",(0,s.jsx)(l.code,{children:"MyKey"}),":"]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",metastring:'title="Example key implementation"',children:"class MyKey {\n    final ValueCell a;\n    final ValueCell b;\n    \n    MyKey(this.a, this.b);\n    \n    @override\n    bool operator ==(other) => other is MyKey &&\n        a == other.a &&\n        b == other.b;\n        \n    @override\n    int get hashCode => Object.hash(runtimeType, a, b);     \n}\n"})}),"\n",(0,s.jsxs)(l.p,{children:["The\n",(0,s.jsx)(l.a,{href:"https://pub.dev/documentation/live_cells_core/latest/live_cells_internals/live_cells_internals-library.html",children:(0,s.jsx)(l.code,{children:"live_cells_internals"})}),"\nlibrary provides the key base classes ",(0,s.jsx)(l.code,{children:"CellKey1"}),", ",(0,s.jsx)(l.code,{children:"CellKey2"})," up to\n",(0,s.jsx)(l.code,{children:"CellKey5"}),", which allow you to quickly create a key that is identified\nby 1, 2 up to 5 values. These cells already implement ",(0,s.jsx)(l.code,{children:"=="})," and\n",(0,s.jsx)(l.code,{children:"hashCode"}),"."]}),"\n",(0,s.jsx)(l.admonition,{type:"important",children:(0,s.jsxs)(l.p,{children:["The ",(0,s.jsx)(l.code,{children:"runtimeType"})," is taken into account in the imlementation of ",(0,s.jsx)(l.code,{children:"=="}),"\nand ",(0,s.jsx)(l.code,{children:"hashCode"}),". Therefore two keys of different subclasses of\n",(0,s.jsx)(l.code,{children:"CellKey2"}),", for example, will not compare ",(0,s.jsx)(l.code,{children:"=="})," even if the key values\nare ",(0,s.jsx)(l.code,{children:"=="}),"."]})}),"\n",(0,s.jsxs)(l.p,{children:[(0,s.jsx)(l.code,{children:"MyKey"})," can also be implemented using ",(0,s.jsx)(l.code,{children:"CellKey2"})," as follows:"]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",metastring:'title="Implementation of MyKey using CellKey2"',children:"import 'package:live_cells_core/live_cells_internals.dart';\n\nclass MyKey extends CellKey2 {\n    MyKey(super.value1, super.value2);\n}\n"})}),"\n",(0,s.jsxs)(l.admonition,{type:"danger",children:[(0,s.jsxs)(l.p,{children:["Don't give the same key to functionally different cells. ",(0,s.jsx)(l.strong,{children:"Don't do\nthis"}),":"]}),(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",children:"final a = ValueCell.computed(() => a() + b(),\n    key: MyKey(a, b)\n);\n\nfinal b = ValueCell.computed(() => a() * b(),\n    key: MyKey(a, b)\n);\n"})}),(0,s.jsx)(l.p,{children:"Not unless you want bad things to happen."})]}),"\n",(0,s.jsx)(l.h2,{id:"keys-for-mutable-cells",children:"Keys for mutable cells"}),"\n",(0,s.jsxs)(l.p,{children:["You can also assign keys to mutable cells, however if you do the\ncell's value may not be read or written while it is inactive,\ni.e. while it has no observers. This restriction applies to cells\ncreated with ",(0,s.jsx)(l.code,{children:"MutableCell"})," and ",(0,s.jsx)(l.code,{children:"MutableCell.computed"}),". If the value of\na keyed mutable cell is read before an observer is added an\n",(0,s.jsx)(l.code,{children:"InactivePersistentStatefulCellError"})," exception is thrown."]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",children:"final a = MutableCell(0, key: MyKey(...));\n\n// Throws InactivePersistentStatefulCellError\nprint(a.value);\n"})}),"\n",(0,s.jsxs)(l.p,{children:["The reason for this restriction is that the cell's state is\nautomatically removed from the global cell state table when the cell's\nlast observer is removed. Mutable cells without a key can safely\nmaintain a reference to that state, even after it has technically been\n",(0,s.jsx)(l.em,{children:"disposed"}),", because they do not share the state with other\ncells. However, mutable cells with a key share their state with other\ncells which have the same key, therefore they cannot maintain a\nreference to their state after it has been removed from the global\nstate table, since there is no guarantee at that point that all such\ncells will be referencing the same state object."]}),"\n",(0,s.jsxs)(l.p,{children:["To be able to read/write the value of a keyed ",(0,s.jsx)(l.code,{children:"MutableCell"})," when it\nmay be inactive, you'll have to call ",(0,s.jsx)(l.code,{children:".hold()"})," to keep the cell's\nstate from being disposed."]}),"\n",(0,s.jsx)(l.pre,{children:(0,s.jsx)(l.code,{className:"language-dart",children:"final a = MutableCell(0, key: MyKey(...));\n\n// Ensure the state of a will not be disposed\nfinal hold = a.hold();\n\nprint(a.value);\na.value = 10;\n\n...\n// Call release when you will no longer use `a`\nhold.release();\n"})}),"\n",(0,s.jsxs)(l.p,{children:["Note ",(0,s.jsx)(l.code,{children:".release()"})," is called, on the object returned by ",(0,s.jsx)(l.code,{children:"hold()"}),", when\nthe mutable cell will no longer be used. This allows its state to be\ndisposed."]}),"\n",(0,s.jsx)(l.admonition,{type:"caution",children:(0,s.jsx)(l.p,{children:"When the state of a keyed mutable cell is recreated after disposal,\ndue to being observed again, it's value will be reset which is not the\ncase with non-keyed mutable cells."})}),"\n",(0,s.jsx)(l.admonition,{type:"important",children:(0,s.jsxs)(l.p,{children:[(0,s.jsx)(l.code,{children:"CellWidget"})," ensures that all mutable cells created within it are\nactive while the widget is mounted."]})}),"\n",(0,s.jsx)(l.admonition,{type:"info",children:(0,s.jsx)(l.p,{children:"This restriction does not apply to stateless mutable computed cells\nsince they don't have a state. Most methods and properties, provided\nby this library, that return keyed mutable computed cells actually\nreturn stateless mutable computed cells. These will be covered in the\nnext section."})})]})}function h(e={}){const{wrapper:l}={...(0,t.R)(),...e.components};return l?(0,s.jsx)(l,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,l,n)=>{n.d(l,{R:()=>a,x:()=>c});var s=n(6540);const t={},i=s.createContext(t);function a(e){const l=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(l):{...l,...e}}),[l,e])}function c(e){let l;return l=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(i.Provider,{value:l},e.children)}}}]);