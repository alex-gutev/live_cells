"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[897],{7587:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>r});var i=t(4848),s=t(8453);const l={title:"Effect Cells",description:"Observing the result of side effects using cells",sidebar_position:13},c="Effect Cells",o={id:"basics/effect-cells",title:"Effect Cells",description:"Observing the result of side effects using cells",source:"@site/docs/basics/effect-cells.md",sourceDirName:"basics",slug:"/basics/effect-cells",permalink:"/docs/basics/effect-cells",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:13,frontMatter:{title:"Effect Cells",description:"Observing the result of side effects using cells",sidebar_position:13},sidebar:"tutorialSidebar",previous:{title:"Meta Cells",permalink:"/docs/basics/meta-cells"},next:{title:"Self Cells",permalink:"/docs/basics/self-cells"}},d={},r=[{value:"Observing Side Effects",id:"observing-side-effects",level:2},{value:"Loading Indicator",id:"loading-indicator",level:3},{value:"Performing Actions",id:"performing-actions",level:3},{value:"Observing Cells in Effect Cells",id:"observing-cells-in-effect-cells",level:2},{value:"Code Organization",id:"code-organization",level:2},{value:"Why use Effect Cells?",id:"why-use-effect-cells",level:2}];function a(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"effect-cells",children:"Effect Cells"}),"\n",(0,i.jsxs)(n.p,{children:["An ",(0,i.jsx)(n.em,{children:"effect cell"})," is a cell that performs a side effect and allows the\nresult/status of the effect to be observed by observing a cell."]}),"\n",(0,i.jsxs)(n.p,{children:["An effect cell is tied to an ",(0,i.jsx)(n.a,{href:"action-cells",children:"action cell"}),". This means\nthat the side effect, which is defined in the value computation\nfunction of the effect cell, only runs when the action cell is\ntriggered, and only once per trigger."]}),"\n",(0,i.jsxs)(n.p,{children:["Effect cells are created using the\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ActionCellEffectExtension/effect.html",children:(0,i.jsx)(n.code,{children:".effect"})}),"\nmethod provided by action cells (",(0,i.jsx)(n.code,{children:"ValueCell<void>"}),"), with the side\neffect defined in the function provided to ",(0,i.jsx)(n.code,{children:"effect"}),"."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Creating an effect cell"',children:"final ValueCell<void> action;\n\n...\n\nfinal effect = action.effect(() {\n    // A hypothetical form submission\n    return submitForm();\n});\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the example above, an effect cell (",(0,i.jsx)(n.code,{children:"effect"}),") is created that is\ntied to an ",(0,i.jsx)(n.code,{children:"action"})," cell. The side effect, defined by ",(0,i.jsx)(n.code,{children:"effect"})," is a\nform submission effected by the (hypothetical) ",(0,i.jsx)(n.code,{children:"submitForm()"}),"\nfunction. The ",(0,i.jsx)(n.code,{children:"submitForm"})," function is run whenever ",(0,i.jsx)(n.code,{children:"action"})," is\ntriggered. Notice that the value of ",(0,i.jsx)(n.code,{children:"submitForm()"})," is returned in the\neffect function. This becomes the value of the effect cell which\nallows us to observe the result/status of the effect by observing the\n",(0,i.jsx)(n.code,{children:"effect"})," cell."]}),"\n",(0,i.jsxs)(n.p,{children:["This is different from ",(0,i.jsx)(n.code,{children:"ValueCell.watch"})," in the following ways:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The result of the side effect can be observed by observing the\neffect cell ",(0,i.jsx)(n.code,{children:"effect"}),", in this case. This is useful for displaying a\nloading indicator while the side effect is in progress."]}),"\n",(0,i.jsxs)(n.li,{children:["The side effect function is only run when the action cell is\ntriggered, whereas ",(0,i.jsx)(n.code,{children:"ValueCell.watch"})," is run once initially when it\nis defined in order to discover its dependencies."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The difference between an effect cell and a regular computed cell is\nthat the effect cell guarantees that the effect defined in the value\ncomputation function will only be run once per trigger of the action\nto which it is tied. On the other hand a computed cell is intended to\nbe used with a pure function that computes a value but has no side\neffect, and thus makes no guarantees about how many times its compute\nfunction is called."}),"\n",(0,i.jsx)(n.admonition,{type:"important",children:(0,i.jsx)(n.p,{children:"An effect cell has to be observed, and its value referenced, in order\nfor the side effect to be run. If the action cell is triggered, but\nthe effect cell has no observers, the side effect is not run."})}),"\n",(0,i.jsx)(n.h2,{id:"observing-side-effects",children:"Observing Side Effects"}),"\n",(0,i.jsx)(n.p,{children:"As mentioned earlier, effect cells are useful for observing the\nresult/status of a side effect. In the following examples, we'll\ndefine an effect cell that simulates a form submission, and observe it\nto display a loading indicator while the submission is ongoing."}),"\n",(0,i.jsx)(n.p,{children:"First let's define a widget, with an action cell that is triggered by\na button."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"class Example extends CellWidget {\n  @override\n  Widget build(BuildContext context) {\n    final submit = ActionCell();\n    \n    return LiveFilledButton(\n      press: submit\n      child: Text('Submit')\n    );\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Now let's define the effect that is run when the ",(0,i.jsx)(n.code,{children:"submit"})," action cell\nis triggered, which happens when the button is pressed."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Widget build(BuildContext context) {\n  final submit = ActionCell();\n    \n  final submission = submit.effect(() async {\n    return await Future.delayed(Duration(seconds: 3), () => true);\n  });\n    \n  ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["We've used ",(0,i.jsx)(n.code,{children:"Future.delayed"})," to simulate a network request, with\n",(0,i.jsx)(n.code,{children:"true"}),", indicating success, returned after three seconds. In a real\napplication, you would substitute ",(0,i.jsx)(n.code,{children:"Future.delayed"})," with an actual\nHTTP request."]}),"\n",(0,i.jsx)(n.p,{children:"There are two things we want to achieve:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Display a loading indicator while the submission is in progress."}),"\n",(0,i.jsx)(n.li,{children:"Display a dialog with a message indicating whether the request\nsucceeded or failed."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"loading-indicator",children:"Loading Indicator"}),"\n",(0,i.jsxs)(n.p,{children:["To display the loading indicator we can simply observe the\n",(0,i.jsx)(n.code,{children:"submission"})," effect cell, and use ",(0,i.jsx)(n.code,{children:"isComplete"}),", from ",(0,i.jsx)(n.a,{href:"async-cells#checking-if-complete",children:"Asynchronous\nCells"}),", to conditionally display the\nindicator."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Widget build(BuildContext context) {\n  ...\n  \n  final isLoading = !submission.isComplete();\n  \n  return LiveFilledButton(\n    press: submit,\n    enabled: submission.isComplete,\n    child: isLoading ? CircularProgressIndicator() : Text('Submit')\n  );\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"LiveFilledButton"})," accepts an ",(0,i.jsx)(n.code,{children:"enabled"})," argument, which takes a\nboolean cell that controls whether the button is enabled or disabled."]})}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"submission.isComplete()"})," is false, a progress indicator is\ndisplayed in the button and the button is disabled."]}),"\n",(0,i.jsxs)(n.p,{children:["When the ",(0,i.jsx)(n.code,{children:"submission"})," effect cell is accessed before the effect has\nrun for the first time, an ",(0,i.jsx)(n.code,{children:"UninitializedCellError"})," exception is\nthrown. In this case ",(0,i.jsx)(n.code,{children:"submission.isComplete()"})," is true since the value\nof ",(0,i.jsx)(n.code,{children:"submission"})," is not a ",(0,i.jsx)(n.code,{children:"Future"})," that is pending, therefore the\nprogress indicator is not shown until the button is pressed."]}),"\n",(0,i.jsxs)(n.p,{children:["Pressing the button results in the progress indicator being shown\nuntil the ",(0,i.jsx)(n.code,{children:"Future"})," held in ",(0,i.jsx)(n.code,{children:"submission"}),' completes, which in this\n"simulated" example happens after three seconds.']}),"\n",(0,i.jsx)(n.h3,{id:"performing-actions",children:"Performing Actions"}),"\n",(0,i.jsxs)(n.p,{children:["To show the dialog we can observe the ",(0,i.jsx)(n.code,{children:"submission"})," effect cell in a\nwatch function:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Widget build(BuildContext context) {\n  final submission = ...;\n    \n  ValueCell.watch(() {\n    final result = effect.awaited();\n    \n    if (context.mounted) {\n      showDialog(\n        context: context,\n        builder: (context) => AlertDialog(\n          title: Text(result \n              ? 'Success' \n              : 'Error'\n          ),\n          content: Text(result\n              ? 'The submission was successful'\n              : 'Please try again'\n          ),\n          \n          actions: [\n            ElevatedButton(\n              onPressed: () => Navigator.pop(context),\n              child: Text('OK')\n            )\n          ]\n        )\n      );\n    }\n  });\n  \n  ...\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["A watch function is defined that observes the result of the side\neffect using ",(0,i.jsx)(n.code,{children:"submission.awaited"}),". The watch function, which displays\na dialog showing the status of the submission, is only run when the\n",(0,i.jsx)(n.code,{children:"submit"})," action cell is triggered and the ",(0,i.jsx)(n.code,{children:"Future"})," held in\n",(0,i.jsx)(n.code,{children:"submission"})," is completed. This is because ",(0,i.jsx)(n.code,{children:"submission.awaited"})," throws\nan exception until the effect is run and the ",(0,i.jsx)(n.code,{children:"Future"}),", returned by the\neffect function, has completed. The exception prevents the remainder\nof the function from being run."]}),"\n",(0,i.jsxs)(n.p,{children:["Success is indicated by a return value of ",(0,i.jsx)(n.code,{children:"true"})," in the effect\nfunction and failure by a return value of ",(0,i.jsx)(n.code,{children:"false"}),". The value returned\nby the ",(0,i.jsx)(n.code,{children:"submission"})," effect is checked inside the watch function to\nchoose which dialog to display."]}),"\n",(0,i.jsxs)(n.p,{children:["You'll notice a number of unhandled exception notices being printed to\nthe console when running in debug mode. These are expected because\n",(0,i.jsx)(n.code,{children:"submission.awaited"})," throws an exception until it has a result, and\nthese are not handled inside the watch function. To silence the\n",(0,i.jsx)(n.code,{children:"UninitializedCellError"})," and ",(0,i.jsx)(n.code,{children:"PendingAsyncValueError"})," exceptions, use\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/live_cells/ErrorCellExtension/whenReady.html",children:(0,i.jsx)(n.code,{children:".whenReady"})}),". This\nhas the same effect of terminating the watch function, but prevents\nunhandled ",(0,i.jsx)(n.code,{children:"UninitializedCellError"})," and ",(0,i.jsx)(n.code,{children:"PendingAsyncValueError"}),"\nexception notices from being printed to the console."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Silencing unhandled exception notices with .whenReady"',children:"ValueCell.watch(() {\n  final result = effect.awaited.whenReady();\n    \n  if (context.mounted) {\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: Text(result \n            ? 'Success' \n            : 'Error'\n        ),\n        content: Text(result\n            ? 'The submission was successful'\n            : 'Please try again'\n        ),\n        \n        actions: [\n          ElevatedButton(\n            onPressed: () => Navigator.pop(context),\n            child: Text('OK')\n          )\n        ]\n      )\n    );\n  }\n});\n"})}),"\n",(0,i.jsx)(n.h2,{id:"observing-cells-in-effect-cells",children:"Observing Cells in Effect Cells"}),"\n",(0,i.jsxs)(n.p,{children:["The value of another cell can be referenced inside an effect cell\nfunction using the same function call syntax used within\n",(0,i.jsx)(n.code,{children:"ValueCell.computed"}),". However, the difference is that changes in the\nvalue of the referenced cell will not cause the effect function to be\nrun again. The effect function is only run when the action cell, to\nwhich it is tied to, is triggered."]}),"\n",(0,i.jsxs)(n.p,{children:["Let's add some data to the submission. We'll add a switch, which when\non, the submission succeeds and when it is off the submission\nfails. We'll use ",(0,i.jsx)(n.code,{children:"LiveSwitch"})," to bind the state of the switch directly\nto a cell."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"Widget build(BuildContext context) {\n  final submit = ActionCell();\n\n  final succeed = MutableCell(true);\n\n  final submission = submit.effect(() async {\n    final result = succeed();\n    \n    return await Future.delayed(Duration(seconds: 3), () => result);\n  });\n\n  ...\n  \n  return Column(\n    children: [\n      LiveSwitch(\n          value: succeed,\n          enabled: submission.isComplete;\n      ),\n      LiveFilledButton(\n          press: submit,\n          enabled: submission.isComplete,\n          child: isLoading ? CircularProgressIndicator() : Text('Submit')\n      );\n    ]\n  );\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Toggling the switch will now change the result of the ",(0,i.jsx)(n.code,{children:"submission"}),"\ncell, though as mentioned earlier the side effect defined by the\n",(0,i.jsx)(n.code,{children:"submission"})," cell is only run when the button is\npressed. Additionally, ",(0,i.jsx)(n.code,{children:"submission.isComplete"})," is bound to the\n",(0,i.jsx)(n.code,{children:"enabled"})," property of the ",(0,i.jsx)(n.code,{children:"LiveSwitch"}),". As a result, the switch is\ndisabled while the submission is still in progress."]}),"\n",(0,i.jsx)(n.h2,{id:"code-organization",children:"Code Organization"}),"\n",(0,i.jsxs)(n.p,{children:["So far not much thought has been given to the organization of our\ncode. Instead we've directly placed all the cell definitions in the\n",(0,i.jsx)(n.code,{children:"build"})," method of the widget. For this simple example its not an issue\nbut for larger applications its best to separate the cell definitions\nfrom the UI."]}),"\n",(0,i.jsxs)(n.p,{children:["A recommended approach for achieving separation of concerns is to use\ncell factory functions. This is a fancy term for a function which\ncreates a cell. For example, the ",(0,i.jsx)(n.code,{children:"submission"})," effect cell can be\ndefined in a factory function that takes the action cell (",(0,i.jsx)(n.code,{children:"action"}),"),\nfor triggering the effect, and the cell holding the result\n(",(0,i.jsx)(n.code,{children:"succeed"}),"):"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Cell Factory Function"',children:"final FutureCell<bool> submissionCell({\n    required ValueCell<void> action,\n    required ValueCell<bool> succeed\n}) => submit.effect(() async {\n    final result = succeed();\n    return await Future.delayed(Duration(seconds: 3), () => result);\n});\n"})}),"\n",(0,i.jsx)(n.p,{children:"The factory function can then be used in the widget build method as\nfollows:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"@override\nWidget build(BuildContext context) {\n  final submit = ActionCell();\n  final succeed = MutableCell(true);\n  \n  final submission = submissionCell(\n    action: submit,\n    succeed: succeed\n  );\n  \n  ...\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:"The significance of this is that the code defining the cells is now\nmoved out of the widget body, and can be reused throughout the app."}),"\n",(0,i.jsx)(n.h2,{id:"why-use-effect-cells",children:"Why use Effect Cells?"}),"\n",(0,i.jsx)(n.p,{children:"You may be wondering what's the value in using effect cells, when you\ncan achieve the same result without them? The main benefit of using an\neffect cell is that the result / status of the effect, in this case a\n(simulated) form submission, can be observed just like any cell. It\ncan be used in a computed cell / watch function or bound to a widget\nproperty. The alternative would be to manually synchronize the state\nof the side effect with the state of your widgets."}),"\n",(0,i.jsx)(n.p,{children:"For example you would need to do something similar to the following:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final isLoading = MutableCell(false);\n\nFilledButton(\n    onPressed: isLoading() ? null : () async {\n        isLoading.value = true;\n        await submitForm();\n        isLoading.value = false;\n    }\n    \n    child: isLoading()\n      ? CircularProgressIndicator()\n      : Text('Submit')\n);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This leaves room for bugs. If, for example, ",(0,i.jsx)(n.code,{children:"submitForm()"})," throws an\nexception, ",(0,i.jsx)(n.code,{children:"isLoading"})," will not be reset to false, which means your UI\nwill now be stuck in the loading state and your user will not be able\nto retry the request. Using effect cells helps to eliminate bugs such\nas these, which are caused when the state of your UI is not properly\nsynchronized with the state of the side effect."]}),"\n",(0,i.jsx)(n.p,{children:"Of course this doesn't mean you should rush to use effect cells\neverywhere. If effect cells don't make sense for your specific case,\nthen don't use them."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>c,x:()=>o});var i=t(6540);const s={},l=i.createContext(s);function c(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);