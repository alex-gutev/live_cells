"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[541],{7613:(e,t,l)=>{l.r(t),l.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});var s=l(4848),n=l(8453);const a={title:"Lightweight Computed Cells",description:"What are lightweight computed cells and how to create them?",sidebar_position:2},c="Lightweight Computed Cells",i={id:"advanced/lightweight-cells",title:"Lightweight Computed Cells",description:"What are lightweight computed cells and how to create them?",source:"@site/docs/advanced/lightweight-cells.md",sourceDirName:"advanced",slug:"/advanced/lightweight-cells",permalink:"/live_cells/docs/advanced/lightweight-cells",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Lightweight Computed Cells",description:"What are lightweight computed cells and how to create them?",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Cell Keys",permalink:"/live_cells/docs/advanced/cell-keys"}},o={},d=[{value:"Stateful and Stateless Cells",id:"stateful-and-stateless-cells",level:2},{value:"Stateless Computed Cells",id:"stateless-computed-cells",level:2},{value:"When to use Stateless Cells?",id:"when-to-use-stateless-cells",level:2}];function r(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"lightweight-computed-cells",children:"Lightweight Computed Cells"}),"\n",(0,s.jsxs)(t.p,{children:["To understand what a lightweight computed cell is, we first have to go\nover the difference between ",(0,s.jsx)(t.strong,{children:"stateful cells"})," and ",(0,s.jsx)(t.strong,{children:"stateless\ncells"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"stateful-and-stateless-cells",children:"Stateful and Stateless Cells"}),"\n",(0,s.jsxs)(t.p,{children:["Till this point, we've mostly been using stateful cells. A stateful\ncell maintains a state in memory, which consists of the cell's value\nand the set of observers that are observing the cell. ",(0,s.jsx)(t.code,{children:"MutableCell"}),"\nand ",(0,s.jsx)(t.code,{children:"ValueCell.computed(...)"})," both create stateful cells."]}),"\n",(0,s.jsxs)(t.p,{children:["Stateless cells do not maintain a state. This means they do not store\na value, nor do they maintain a set of observers. An example of\nstateless cells that we've used frequently throughout this\ndocumentation is the constant cell, e.g. ",(0,s.jsx)(t.code,{children:"1.cell"}),",\n",(0,s.jsx)(t.code,{children:"'hello'.cell"}),'. These cells are stateless because they do not actually\nstore a value but merely return a "hardcoded" constant.']}),"\n",(0,s.jsx)(t.h2,{id:"stateless-computed-cells",children:"Stateless Computed Cells"}),"\n",(0,s.jsx)(t.p,{children:"A lightweight computed cell is a stateless cell that rather than\nreturning a constant, computes a value as a function of the values of\nother cells."}),"\n",(0,s.jsxs)(t.p,{children:["Unlike a stateful cell created with ",(0,s.jsx)(t.code,{children:"ValueCell.computed"}),", a stateless\ncomputed cell does not cache its value. Instead it is computed on\ndemand whenever the value property is accessed. Stateless computed\ncells do not keep track of their own observers. Instead, all observers\nadded to a stateless computed cell, are added directly to the argument\ncells."]}),"\n",(0,s.jsxs)(t.p,{children:["Stateless computed cells can be created using the ",(0,s.jsx)(t.code,{children:"apply"})," method\nprovided by all cells. ",(0,s.jsx)(t.code,{children:"apply"})," takes a compute function, that is\napplied on the value of the cell, and returns a new stateless computed\ncell. The compute function is called whenever the value of the cell is\naccessed."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Creating a stateless computed cell with .apply()"',children:"final inc = n.apply((n) => n + 1);\nfinal dec = n.apply((n) => n - 1);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This example shows two definitions of stateless computed cells,\nderived from cell ",(0,s.jsx)(t.code,{children:"n"}),":"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"inc"}),", which evaluates to ",(0,s.jsx)(t.code,{children:"n + 1"})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"dec"}),", which evaluates to ",(0,s.jsx)(t.code,{children:"n - 1"})]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["A stateless computed cell with multiple argument cells, can be created\nusing the ",(0,s.jsx)(t.code,{children:"apply"})," method on a record of the argument cells. The\ncompute function is applied with the value of each argument cell\npassed as an argument."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Multi-argument stateless computed cells"',children:"final sum = (a, b).apply((a, b) => a + b);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In this example a stateless computed cell ",(0,s.jsx)(t.code,{children:"sum"})," is defined, which\nevaluates to the sum of cells ",(0,s.jsx)(t.code,{children:"a"})," and ",(0,s.jsx)(t.code,{children:"b"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"apply"})," also takes an optional key argument, by which the returned\ncell is identified:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="apply() with key argument"',children:"final sum = (a, b).apply((a, b) => a + b,\n    key: SumKey(a, b)\n);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The purpose of the key in stateless computed cells, is to prevent the\nsame observer from being added to multiple but functionally equivalent\ncell objects. ",(0,s.jsxs)(t.em,{children:["See ",(0,s.jsx)(t.a,{href:"cell-keys",children:"Cell Keys"})," for more information."]})]}),"\n",(0,s.jsxs)(t.p,{children:["If you want to control when the value properties of each argument are\nreferenced, you can define a lightweight computed cell using the\n",(0,s.jsx)(t.code,{children:"ComputeCell"})," constructor. The constructor takes the ",(0,s.jsx)(t.code,{children:"compute"}),"\nfunction, set of argument cells (",(0,s.jsx)(t.code,{children:"arguments"}),") and an optional ",(0,s.jsx)(t.code,{children:"key"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="ComputeCell constructor"',children:"final logand = ComputeCell(\n    arguments: {a, b},\n    compute: () => a.value && b.value\n);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Notice the argument set has to be specified manually, and the compute\nfunction does not take any arguments. Instead, the values of the\nargument cells have to be referenced manually using the ",(0,s.jsx)(t.code,{children:"value"}),"\nproperty. Because they are referenced manually, we can control when\neach value property is accessed, which is not possible with\n",(0,s.jsx)(t.code,{children:"apply(...)"}),". In this case ",(0,s.jsx)(t.code,{children:"b.value"})," is only referenced if ",(0,s.jsx)(t.code,{children:"a.value"}),"\nis true, which would not be the case if the cell was defined with ",(0,s.jsx)(t.code,{children:"apply"}),"."]}),"\n",(0,s.jsx)(t.admonition,{type:"important",children:(0,s.jsxs)(t.p,{children:["When defining a stateless compute cell, the values of the argument\ncells are referenced directly using the ",(0,s.jsx)(t.code,{children:"value"})," property rather than\nthe function call syntax used with ",(0,s.jsx)(t.code,{children:"ValueCell.computed"}),". The\ndifference between the two is that ",(0,s.jsx)(t.code,{children:"value"}),' simply accesses the value\nof the cell, whereas calling the cell registers it as a\ndependency. Stateless computed cells don\'t track dependencies,\ntherefore there is no need to "call" the cell, and its value can be\naccessed directly.']})}),"\n",(0,s.jsx)(t.h2,{id:"when-to-use-stateless-cells",children:"When to use Stateless Cells?"}),"\n",(0,s.jsxs)(t.p,{children:["Stateless computed cells are useful for lightweight computations, such\nas basic arithmetic and numeric comparisons, where recomputing the\ncell's value every time it is accessed is likely to be faster than\ncaching it, due to the overhead of maintaining a state. For expensive\ncomputations, it's preferable to cache the value and only recompute it\nwhen necessary. If in doubt, you're\nbetter off sticking to ",(0,s.jsx)(t.code,{children:"ValueCell.computed"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},8453:(e,t,l)=>{l.d(t,{R:()=>c,x:()=>i});var s=l(6540);const n={},a=s.createContext(n);function c(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);