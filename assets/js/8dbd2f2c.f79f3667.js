"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[216],{6002:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>r});var s=l(4848),t=l(8453);const i={title:"Cell Keys",description:"What cell keys are and what they are used for.",sidebar_position:1},c="Cell Keys",a={id:"advanced/cell-keys",title:"Cell Keys",description:"What cell keys are and what they are used for.",source:"@site/docs/advanced/cell-keys.md",sourceDirName:"advanced",slug:"/advanced/cell-keys",permalink:"/live_cells/docs/advanced/cell-keys",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Cell Keys",description:"What cell keys are and what they are used for.",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Advanced",permalink:"/live_cells/docs/category/advanced"},next:{title:"Lightweight Computed Cells",permalink:"/live_cells/docs/advanced/lightweight-cells"}},d={},r=[{value:"Keyed cells",id:"keyed-cells",level:2},{value:"Why?",id:"why",level:3},{value:"Which cells have keys?",id:"which-cells-have-keys",level:2},{value:"Keys for your own cells",id:"keys-for-your-own-cells",level:2},{value:"Keys for mutable cells",id:"keys-for-mutable-cells",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"cell-keys",children:"Cell Keys"}),"\n",(0,s.jsx)(n.p,{children:"We stated a couple of times in the documentation that a certain\nproperty returns a keyed cell. Now we'll explain what that actually\nmeans."}),"\n",(0,s.jsx)(n.h2,{id:"keyed-cells",children:"Keyed cells"}),"\n",(0,s.jsxs)(n.p,{children:["A keyed cell is a cell with a key that identifies the cell. If two\ndistinct ",(0,s.jsx)(n.code,{children:"ValueCell"})," instances have the same key, under ",(0,s.jsx)(n.code,{children:"=="}),", then the\ntwo cells compare ",(0,s.jsx)(n.code,{children:"=="}),". In-effect, this allows them to function as\nthough they are the same cell despite being two separate objects."]}),"\n",(0,s.jsxs)(n.p,{children:["Great, so how's that useful? Consider the following code which creates\na ",(0,s.jsx)(n.code,{children:"CellWidget"})," that observes a cell ",(0,s.jsx)(n.code,{children:"a"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"CellWidget.builder((_) {\n    final a = ...;\n    \n    return Text(a());\n});\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"a"})," is created in the widget build function, and observed by the\n",(0,s.jsx)(n.code,{children:"CellWidget"}),". When the ",(0,s.jsx)(n.code,{children:"CellWidget"})," is rebuilt, the build function is\ncalled again, a new ",(0,s.jsx)(n.code,{children:"a"})," is created and the ",(0,s.jsx)(n.code,{children:"CellWidget"})," is now\nobserving the new ",(0,s.jsx)(n.code,{children:"a"})," alongside the previous ",(0,s.jsx)(n.code,{children:"a"}),". With every rebuild\nof the ",(0,s.jsx)(n.code,{children:"CellWidget"}),", a new ",(0,s.jsx)(n.code,{children:"a"})," is being observed. Besides leaking\nmemory, the state of ",(0,s.jsx)(n.code,{children:"a"})," is lost and reset on every build."]}),"\n",(0,s.jsxs)(n.p,{children:["Cell keys were created to avoid this problem. If the ",(0,s.jsx)(n.code,{children:"CellWidget"})," is\nrebuilt and a new ",(0,s.jsx)(n.code,{children:"a"})," is created, BUT with the same key as the\nprevious ",(0,s.jsx)(n.code,{children:"a"}),", the ",(0,s.jsx)(n.code,{children:"CellWidget"})," sees it as the same cell and continues\nobserving the previous ",(0,s.jsx)(n.code,{children:"a"}),". More importantly, the new ",(0,s.jsx)(n.code,{children:"a"})," shares the\nsame state (and hence the same value) as the previous ",(0,s.jsx)(n.code,{children:"a"}),". In-effect\nit is the same cell, just referenced by a different object."]}),"\n",(0,s.jsxs)(n.p,{children:["Remember we said ",(0,s.jsx)(n.code,{children:"CellWidget"})," automatically generates a key for cells\ndefined within its build method. That's how the magic works, it's not\nreally magic now is it, and how the state of cells can be persisted\nacross builds. ",(0,s.jsx)(n.code,{children:"CellWidget"})," automatically generates a key for each\ncell defined in its build function/method that does not already have a\nkey."]}),"\n",(0,s.jsx)(n.p,{children:"Keys are not only useful in widgets, but also in computed cells:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final a = MutableCell(0);\nfinal sum = ValueCell.computed(() => a() + a.previous());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Notice, we directly referenced the ",(0,s.jsx)(n.code,{children:"previous"})," property (which\nreferences the previous value of cell ",(0,s.jsx)(n.code,{children:"a"}),"), in the computed cell. We\nare able to do this because ",(0,s.jsx)(n.code,{children:"previous"})," returns a keyed cell. If it\nweren't for keyed cells we would have to store ",(0,s.jsx)(n.code,{children:"a.previous"}),"\nin a local variable first and reference that in the computed cell,\ni.e. something similar to the following:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final a = MutableCell(0);\nfinal prev = a.previous;\n\nfinal sum = ValueCell.computed(() => a() + prev());\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The second snippet is more verbose and would be inefficient, if\n",(0,s.jsx)(n.code,{children:"previous"})," wasn't a keyed cell, because every ",(0,s.jsx)(n.code,{children:"a.previous"})," would\ncreate a new cell that tracks the previous value of ",(0,s.jsx)(n.code,{children:"a"}),". With keyed\ncells there is only a single ",(0,s.jsx)(n.code,{children:"a.previous"})," cell that is tracking the\nprevious value of ",(0,s.jsx)(n.code,{children:"a"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"why",children:"Why?"}),"\n",(0,s.jsx)(n.p,{children:"You may be asking why keyed cells instead of just caching the created\ncells in private properties? There's three reasons for this:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It keeps the core cell classes small."}),"\n",(0,s.jsxs)(n.li,{children:["All additional functionality ",(0,s.jsx)(n.code,{children:".previous"}),", ",(0,s.jsx)(n.code,{children:".wait"}),", ",(0,s.jsx)(n.code,{children:".delayed"}),",\n",(0,s.jsx)(n.code,{children:".first"}),", ",(0,s.jsx)(n.code,{children:".last"}),", ..., can be kept in extensions on the relevant\n",(0,s.jsx)(n.code,{children:"ValueCell"})," classes rather than bloating the classes themselves."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"live_cell_extension"})," (see ",(0,s.jsx)(n.a,{href:"/docs/basics/user-defined-types",children:"User Defined\nTypes"}),") would not have been\npossible without cell keys."]}),"\n",(0,s.jsxs)(n.li,{children:["This allows users of the library to extend the cell classes with\ntheir own properties, e.g. ",(0,s.jsx)(n.code,{children:".foo"}),", which can be used just like a\nbuilt in property."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"which-cells-have-keys",children:"Which cells have keys?"}),"\n",(0,s.jsx)(n.p,{children:"The cells returned by cell property getters are always keyed\ncells. This includes (but is not limited to):"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"List cell extension properties:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".first"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".last"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:".length"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Map cell extension properties"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"previous"})," cells"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"peek"})," cells"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Cell property accessors generated for classes annotated with\n",(0,s.jsx)(n.code,{children:"@CellExtension"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Also the following cells are keyed:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Constant cells"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"Cells returned by the indexing operator on List and Map cells:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"list[1.cell]"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.code,{children:"map['key'.cell]"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Equality comparison cells created with ",(0,s.jsx)(n.code,{children:"eq"})," and ",(0,s.jsx)(n.code,{children:"neq"})]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["To be sure whether a specific method returns a keyed cell or not,\nconsult the ",(0,s.jsx)(n.a,{href:"https://pub.dev/documentation/live_cells/latest/",children:"API\nReference"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"keys-for-your-own-cells",children:"Keys for your own cells"}),"\n",(0,s.jsxs)(n.p,{children:["You can assign a key to your own computed cells, created with\n",(0,s.jsx)(n.code,{children:"ValueCell.computed"}),", by providing the key in the ",(0,s.jsx)(n.code,{children:"key"})," argument:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="Keyed computed cell"',children:"final cell = ValueCell.computed(() => a() + b(),\n    key: MyKey(a, b)\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Any object which overloads ",(0,s.jsx)(n.code,{children:"=="})," and ",(0,s.jsx)(n.code,{children:"hashCode"})," can serve as a cell\nkey. For your own keys, you're generally encouraged to do the following:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use a class per key type. For example if you have a function which\nreturns a cell, create a key class that is only used by that\nfunction."}),"\n",(0,s.jsxs)(n.li,{children:["If your cell depends on other cells, include those cells in the key\nclass and in its implementation of ",(0,s.jsx)(n.code,{children:"=="}),"."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["An example implementation of ",(0,s.jsx)(n.code,{children:"MyKey"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",metastring:'title="Example key implementation"',children:"class MyKey {\n    final ValueCell a;\n    final ValueCell b;\n    \n    MyKey(this.a, this.b);\n    \n    @override\n    bool operator ==(other) => other is MyKey &&\n        a == other.a &&\n        b == other.b;\n        \n    @override\n    int get hashCode => Object.hash(runtimeType, a, b);     \n}\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"danger",children:[(0,s.jsxs)(n.p,{children:["Don't give the same key to functionally different cells. ",(0,s.jsx)(n.strong,{children:"Don't do\nthis"})]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final a = ValueCell.computed(() => a() + b(),\n    key: MyKey(a, b)\n);\n\nfinal b = ValueCell.computed(() => a() * b(),\n    key: MyKey(a, b)\n);\n"})}),(0,s.jsx)(n.p,{children:"Not unless you want bad things to happen."})]}),"\n",(0,s.jsx)(n.h2,{id:"keys-for-mutable-cells",children:"Keys for mutable cells"}),"\n",(0,s.jsxs)(n.p,{children:["If you assign a key to a mutable cell, created with ",(0,s.jsx)(n.code,{children:"MutableCell"})," or\n",(0,s.jsx)(n.code,{children:"MutableCell.computed"}),", you'll have to manually dispose the cell when\nyou're no longer using it, by calling its ",(0,s.jsx)(n.code,{children:".dispose()"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-dart",children:"final a = MutableCell(0);\n...\n// When `a` will no longer be used\na.dispose();\n"})}),"\n",(0,s.jsx)(n.p,{children:"This is because automatic disposal happens when the cell's last\nobserver is removed. However a mutable cell can reasonably be expected\nto have its value assigned even when it doesn't have any observers. All\nmutable cells with the same key, will have to share the same state and\nhence the same value. This means the state has to be kept in the\nglobal cell state table, even when it doesn't have any observers."}),"\n",(0,s.jsx)(n.p,{children:"You don't have to manually dispose mutable cells without a key, since\ntheir state is not shared with other cells and hence not kept in a\nglobal state table."}),"\n",(0,s.jsx)(n.admonition,{type:"important",children:(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"CellWidget"})," takes care of automatically disposing all ",(0,s.jsx)(n.code,{children:"MutableCell"}),"s\ndefined within it when the widget's element is unmounted, so you don't\nhave to call ",(0,s.jsx)(n.code,{children:"dispose"})," manually."]})}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["Stateless mutable computed cells do not require a ",(0,s.jsx)(n.code,{children:"dispose"})," method to\nbe called, since they do not have any state to speak of. Most methods\nand properties, provided by this library, that return keyed mutable\ncomputed cells actually return stateless mutable computed cells. These\nwill be covered in the next section."]})})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>c,x:()=>a});var s=l(6540);const t={},i=s.createContext(t);function c(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);