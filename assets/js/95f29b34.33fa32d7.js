"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[269],{9357:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>d});var s=n(4848),i=n(8453);const l={title:"User Defined Types",description:"Extending cells with accessors for your own classes",sidebar_position:8},r="User Defined Types",a={id:"basics/user-defined-types",title:"User Defined Types",description:"Extending cells with accessors for your own classes",source:"@site/docs/basics/user-defined-types.md",sourceDirName:"basics",slug:"/basics/user-defined-types",permalink:"/live_cells/docs/basics/user-defined-types",draft:!1,unlisted:!1,editUrl:"https://github.com/alex-gutev/live_cells/docs/basics/user-defined-types.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"User Defined Types",description:"Extending cells with accessors for your own classes",sidebar_position:8},sidebar:"tutorialSidebar",previous:{title:"State Restoration",permalink:"/live_cells/docs/basics/state-restoration"}},o={},d=[{value:"Live Cell Extension",id:"live-cell-extension",level:2},{value:"Generating the Code",id:"generating-the-code",level:3},{value:"Binding to Properties",id:"binding-to-properties",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"user-defined-types",children:"User Defined Types"}),"\n",(0,s.jsxs)(t.p,{children:["So far we've used cells holding strings and numbers, and an\n",(0,s.jsx)(t.code,{children:"enum"}),". What about types defined by your own classes?"]}),"\n",(0,s.jsxs)(t.p,{children:["A cell can generally hold a value of any type, as long as ",(0,s.jsx)(t.code,{children:"=="})," is\nsuitably defined."]}),"\n",(0,s.jsx)(t.h2,{id:"live-cell-extension",children:"Live Cell Extension"}),"\n",(0,s.jsxs)(t.p,{children:["The\n",(0,s.jsx)(t.a,{href:"https://pub.dev/packages/live_cell_extension",children:(0,s.jsx)(t.code,{children:"live_cell_extension"})}),"\npackage provides a source code generator that allows you to extend the\ncore cell interfaces, ",(0,s.jsx)(t.code,{children:"ValueCell"})," and ",(0,s.jsx)(t.code,{children:"MutableCell"}),", with accessors\nfor properties of your own classes."]}),"\n",(0,s.jsx)(t.p,{children:"To understand what this means, consider the following class:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Person class"',children:"class Person {\n\tfinal String firstName;\n\tfinal String lastName;\n\tfinal int age;\n\t\n\tconst Person({\n\t\trequired this.firstName,\n\t\trequired this.lastName,\n\t\trequired this.age\n\t});\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Let's say you have a cell holding a ",(0,s.jsx)(t.code,{children:"Person"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Person cell"',children:"final person = MutableCell(\n\tPerson(\n\t\tfirstName: 'John',\n\t\tlastName: 'Smith',\n\t\tage: 25\n\t)\n);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["To access a property of the ",(0,s.jsx)(t.code,{children:"Person"})," held in the cell, you will need\nto defined a computed cell:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Accessing properties in cells"',children:"final firstName = ValueCell.computed(() => person().firstName);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If you want the ",(0,s.jsx)(t.code,{children:"firstName"})," cell to be settable, so that setting the\nvalue of ",(0,s.jsx)(t.code,{children:"firstName"})," updates the ",(0,s.jsx)(t.code,{children:"person"})," cell, you'll need to define\na ",(0,s.jsx)(t.code,{children:"copyWith"})," method and a mutable computed cell:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Mutating properties in cells"',children:"final firstName = MutableCell.computed(() => person().firstName, (name) {\n\tperson.value = person.value.copyWith(\n\t\tfirstName: name\n\t);\n});\n"})}),"\n",(0,s.jsx)(t.p,{children:"This is the definition of boilerplate and will quickly become tiring."}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"live_cell_extension"})," package automatically generates this code\nfor you, so that instead of the above, you can write the following:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Generated ValueCell property accessors"',children:"final firstName = person.firstName;\n"})}),"\n",(0,s.jsxs)(t.p,{children:["And to update the value of the ",(0,s.jsx)(t.code,{children:"firstName"})," property:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Generated MutableCell property accessors"',children:"person.firstName = 'Jane';\n"})}),"\n",(0,s.jsxs)(t.p,{children:["That's it, no need to write a ",(0,s.jsx)(t.code,{children:"copyWith"})," method either. This ties in\nwith Live Cell's design principle that cells should be\nindistinguishable, as much as is possible, from the values they hold."]}),"\n",(0,s.jsx)(t.h3,{id:"generating-the-code",children:"Generating the Code"}),"\n",(0,s.jsxs)(t.p,{children:["To make this work you'll need to add the ",(0,s.jsx)(t.code,{children:"live_cell_extension"})," package\nto the ",(0,s.jsx)(t.code,{children:"dev_dependencies"})," of your ",(0,s.jsx)(t.code,{children:"pubspec.yaml"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"dev_dependencies:\n\tlive_cell_extension: 0.3.0\n\t...\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Then annotate the classes, for which you want accessors to be\ngenerated, with ",(0,s.jsx)(t.code,{children:"CellExtension"}),". If you want mutable cell accessors to\nalso be generated, add ",(0,s.jsx)(t.code,{children:"mutable: true"})," to the annotation arguments."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="person.dart"',children:"part 'person.g.dart';\n\n@CellExtension(mutable: true)\nclass Person {\n\tfinal String firstName;\n\tfinal String lastName;\n\tfinal int age;\n\t\n\tconst Person({\n\t\trequired this.firstName,\n\t\trequired this.lastName,\n\t\trequired this.age\n\t});\n}\n"})}),"\n",(0,s.jsx)(t.admonition,{type:"caution",children:(0,s.jsxs)(t.p,{children:["Don't forget to include the ",(0,s.jsx)(t.code,{children:"<filename>.g.dart"})," file. This is where\nthe code will be generated."]})}),"\n",(0,s.jsx)(t.p,{children:"Next you'll need to run the following command in the root directory of\nyour project:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-sh",children:"flutter pub run build_runner build\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This will generate the ",(0,s.jsx)(t.code,{children:".g.dart"})," files, which contain the generated\nclass property accessors."]}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"ValueCell"})," accessors are defined in an extension with the name of\nthe class followed by ",(0,s.jsx)(t.code,{children:"CellExtension"}),". The ",(0,s.jsx)(t.code,{children:"MutableCell"})," accessors are\ndefined in an extension with the name of the class followed by\n",(0,s.jsx)(t.code,{children:"MutableCellExtension"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"binding-to-properties",children:"Binding to Properties"}),"\n",(0,s.jsx)(t.p,{children:"Using the generated property accessors, we can define a form for\npopulating the class properties simply by binding the property cells,\nretrieved using the generated accessors, to the appropriate widgets."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",metastring:'title="Binding directly to properties"',children:"Widget personForm(MutableCell<Person> person) => Column(\n\tchildren: [\n\t\tText('First Name:'),\n\t\tCellTextField(\n\t\t\tcontent: person.firstName\n\t\t),\n\t\tText('Last Name:'),\n\t\tCellTextField(\n\t\t\tcontent: person.lastName\n\t\t),\n\t\tText('Age:'),\n\t\tnumberField(person.age)\n\t]\n);\n"})}),"\n",(0,s.jsxs)(t.p,{children:["We used the ",(0,s.jsx)(t.code,{children:"numberField"})," widget defined earlier, for the ",(0,s.jsx)(t.code,{children:"age"}),"\nproperty."]}),"\n",(0,s.jsx)(t.admonition,{type:"info",children:(0,s.jsxs)(t.p,{children:["The form is not wrapped in a ",(0,s.jsx)(t.code,{children:"StaticWidget"})," since it will only be used\nwithin a static widget."]})}),"\n",(0,s.jsx)(t.p,{children:"We can then use this form as follows:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-dart",children:"Widget example() => StaticWidget.builder((_) {\n\tfinal person = MutableCell(\n\t\tPerson(\n\t\t\tfirstName: 'John',\n\t\t\tlastName: 'Smith',\n\t\t\tage: 25\n\t\t)\n\t);\n\t\n\treturn Column(\n\t\tchildren: [\n\t\t\tpersonForm(person),\n\t\t\tCellText(\n\t\t\t\tdata: ValueCell.computed(\n\t\t\t\t\t() => '${person.firstName()} ${person.lastName()}: ${person.age()} years'\n\t\t\t\t)\n\t\t\t),\n\t\t\tElevatedButton(\n\t\t\t\tchild: Text('Save'),\n\t\t\t\t// A hypothetical savePerson function\n\t\t\t\tonPressed: () => savePerson(person.value)\n\t\t\t),\n\t\t\tElevatedButton(\n\t\t\t\tchild: Text('Reset'),\n\t\t\t\tonPressed: () => person.value = Person(\n\t\t\t\t\tfirstName: 'John',\n\t\t\t\t\tlastName: 'Smith',\n\t\t\t\t\tage: 25\n\t\t\t\t)\n\t\t\t)\t\n\t\t]\n\t);\n});\n"})}),"\n",(0,s.jsxs)(t.p,{children:["In this example we used the ",(0,s.jsx)(t.code,{children:"personForm"})," widget defined earlier."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The details of the person are displayed in a ",(0,s.jsx)(t.code,{children:"CellText"}),", which is\nautomatically updated when the person's details are changed."]}),"\n",(0,s.jsxs)(t.li,{children:['The "Save" button saves the entered details, which are held in the\n',(0,s.jsx)(t.code,{children:"person"})," cell."]}),"\n",(0,s.jsxs)(t.li,{children:['The "Reset" button resets the form fields to their defaults by\ndirectly assigning a default ',(0,s.jsx)(t.code,{children:"Person"})," to the ",(0,s.jsx)(t.code,{children:"person"})," cell."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"The benefits of this, as opposed to using the tools already available\nin Flutter, are:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"No need to write event handlers and state synchronization code for\nacquiring input from the user. This is all handled automatically."}),"\n",(0,s.jsxs)(t.li,{children:["You can focus directly on the representation of your data and think\nin terms of your data, rather than thinking in terms of widget ",(0,s.jsx)(t.code,{children:"State"}),"."]}),"\n",(0,s.jsx)(t.li,{children:"Your widgets are bound directly to your data and kept in sync. There\nis no chance of you accidentally forgetting to synchronize them with\nyour data and vice versa, which eliminates a whole class of bugs."}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const i={},l=s.createContext(i);function r(e){const t=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(l.Provider,{value:t},e.children)}}}]);