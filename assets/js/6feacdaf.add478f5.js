"use strict";(self.webpackChunkmy_website_2=self.webpackChunkmy_website_2||[]).push([[553],{7512:(e,n,l)=>{l.r(n),l.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>o});var i=l(4848),t=l(8453);const s={title:"Cell Expressions",description:"Creating cells using expressions",sidebar_position:3},a="Cell Expressions",r={id:"basics/cell-expressions",title:"Cell Expressions",description:"Creating cells using expressions",source:"@site/docs/basics/cell-expressions.md",sourceDirName:"basics",slug:"/basics/cell-expressions",permalink:"/docs/basics/cell-expressions",draft:!1,unlisted:!1,editUrl:"https://github.com/alex-gutev/live_cells/docs/basics/cell-expressions.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Cell Expressions",description:"Creating cells using expressions",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Cells in Widgets",permalink:"/docs/basics/cell-widgets"},next:{title:"Live Cell Widgets",permalink:"/docs/basics/live-cell-widgets"}},c={},o=[{value:"Arithmetic",id:"arithmetic",level:2},{value:"Equality",id:"equality",level:2},{value:"Logic and selection",id:"logic-and-selection",level:2},{value:"Aborting a computation",id:"aborting-a-computation",level:2},{value:"Exception Handling",id:"exception-handling",level:2},{value:"Previous Values",id:"previous-values",level:2},{value:"Peeking Cells",id:"peeking-cells",level:2}];function d(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"cell-expressions",children:"Cell Expressions"}),"\n",(0,i.jsxs)(n.p,{children:["This library provides a number of tools for building expressions of\ncells without requiring a computed cell to be created explicitly using\n",(0,i.jsx)(n.code,{children:"ValueCell.computed"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"arithmetic",children:"Arithmetic"}),"\n",(0,i.jsxs)(n.p,{children:["The arithmetic and relational (",(0,i.jsx)(n.code,{children:"<"}),", ",(0,i.jsx)(n.code,{children:"<="}),", ",(0,i.jsx)(n.code,{children:">"}),", ",(0,i.jsx)(n.code,{children:">="}),") operators, when\napplied to cells holding numeric values, return cells which compute the\nresult of the expression."]}),"\n",(0,i.jsx)(n.p,{children:"This allows a computation to be defined directly as an expression of\ncells. For example the following cell computes the sum of two cells:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Arithmetic Expressions"',children:"final a = MutableCell(1);\nfinal b = MutableCell(2);\n\nfinal sum = a + b;\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["This definition of the sum cell is not only simpler than the\ndefinition using ",(0,i.jsx)(n.code,{children:"ValueCell.computed"})," but is also more efficient since\nthe argument cells are determined at compile-time."]})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"sum"})," cell is a cell like any other, and can be observed by a\nwatch function, observed by a widget (using ",(0,i.jsx)(n.code,{children:"CellWidget"}),") and can\nappear as an argument in a computed cell."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Observing expression cells"',children:"final watcher = ValueCell.watch(() => print('${sum()}'));\n\na.value = 5; // Prints: 7\nb.value = 4; // Prints: 9\n"})}),"\n",(0,i.jsx)(n.p,{children:"Expressions of cells can be arbitrarily complex:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Complex Cell Expressions"',children:"final x = a * b + c / d;\nfinal y = x < e;\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["To include a constant in a cell expression, use the ",(0,i.jsx)(n.code,{children:".cell"})," property\non the constant if available or wrap it in a cell using\n",(0,i.jsx)(n.code,{children:"ValueCell.value"}),"."]})}),"\n",(0,i.jsx)(n.h2,{id:"equality",children:"Equality"}),"\n",(0,i.jsxs)(n.p,{children:["Every cell provides the ",(0,i.jsx)(n.code,{children:"eq"})," and ",(0,i.jsx)(n.code,{children:"neq"})," methods which compare whether the cell\nis equal or not equal to another cell, respectively. Like the arithmetic operators, these\nmethods return cells which perform the comparison."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Equality Comparison"',children:"final eq = a.eq(b);   // eq() == true when a() == b()\nfinal neq = a.neq(b); // neq() == true when a() != b()\n"})}),"\n",(0,i.jsx)(n.h2,{id:"logic-and-selection",children:"Logic and selection"}),"\n",(0,i.jsxs)(n.p,{children:["Cells holding ",(0,i.jsx)(n.code,{children:"bool"})," values are extended with the following methods:"]}),"\n",(0,i.jsxs)("dl",{children:[(0,i.jsx)("dt",{children:(0,i.jsx)(n.code,{children:"and"})}),(0,i.jsx)("dd",{children:"Creates a cell with a value that is the logical and of two cells"}),(0,i.jsx)("dt",{children:(0,i.jsx)(n.code,{children:"or"})}),(0,i.jsx)("dd",{children:"Creates a cell with a value that is the logical or of two cells"}),(0,i.jsx)("dt",{children:(0,i.jsx)(n.code,{children:"not"})}),(0,i.jsx)("dd",{children:"Creates a cell with a value which is the logical not of a cell"}),(0,i.jsx)("dt",{children:(0,i.jsx)(n.code,{children:"select"})}),(0,i.jsx)("dd",{children:"Creates a cell which selects between the values of two cells based on a condition"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Logic and selection expressions"',children:"final cond = a.or(b);           // cond() is true when a() || b() is true\nfinal cell = cond.select(c, d); // when cond() is true, cell() == c() else cell() == d()\n\na.value = true;\nc.value = 1;\nd.value = 2;\n\nprint(cell.value); // Prints: 1\n\na.value = false;\nb.value = false;\n\nprint(cell.value); // Prints: 2\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The second argument of ",(0,i.jsx)(n.code,{children:"select"})," can be omitted, in which case the\ncell's value will not be updated if the condition is false:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Single argument select"',children:"final cell = cond.select(c);\n\ncond.value = true;\na.value = 2;\n\nprint(cell.value); // Prints 2\n\ncond.value = false;\na.value = 4;\n\nprint(cell.value); // Prints 2\n"})}),"\n",(0,i.jsx)(n.h2,{id:"aborting-a-computation",children:"Aborting a computation"}),"\n",(0,i.jsxs)(n.p,{children:["In the previous section we saw that the ",(0,i.jsx)(n.code,{children:"select"})," method creates a cell\nwhich does not update its argument when the condition cell is ",(0,i.jsx)(n.code,{children:"false"}),"\nand its only given one argument. Under the hood, ",(0,i.jsx)(n.code,{children:"select"})," isn't some\nspecial kind of cell but uses ",(0,i.jsx)(n.code,{children:"ValueCell.none"})," to abort the\ncomputation."]}),"\n",(0,i.jsxs)(n.p,{children:["When ",(0,i.jsx)(n.code,{children:"ValueCell.none"})," is called inside a computed cell, the\ncomputation of the cell's value is aborted and its current value is\npreserved. This can be used to prevent a cell's value from being\nrecomputed when a condition is not met:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Example of ValueCell.none()"',children:"final a = MutableCell(4);\nfinal b = ValueCell.computed(() => a() < 10 ? a() : ValueCell.none());\n\na.value = 6;\nprint(b.value); // Prints 6\n\na.value = 15;\nprint(b.value); // Prints 6\n\na.value = 8;\nprint(b.value); // Prints 8\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If ",(0,i.jsx)(n.code,{children:"ValueCell.none()"})," is called during the computation of the cell's\nfirst value, the cell's value is assigned to ",(0,i.jsx)(n.code,{children:"null"})," by default. If a\ndifferent default value is desired, ",(0,i.jsx)(n.code,{children:"ValueCell.none"})," takes an optional\nargument which is the default value to assign to the cell in this\ncase. For example ",(0,i.jsx)(n.code,{children:"ValueCell.none(3)"})," will assign the value ",(0,i.jsx)(n.code,{children:"3"})," by\ndefault."]}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.p,{children:["The value of a computed cell is only computed if it is actually\nreferenced. ",(0,i.jsx)(n.code,{children:"ValueCell.none"})," only preserves the current value of the\ncell, but this might not be the latest value of the cell if the cell's\nvalue is only referenced conditionally. A good rule of thumb is to use\n",(0,i.jsx)(n.code,{children:"ValueCell.none"})," only for preventing a cell from holding an invalid\nvalue."]})}),"\n",(0,i.jsx)(n.h2,{id:"exception-handling",children:"Exception Handling"}),"\n",(0,i.jsxs)(n.p,{children:["If an exception is thrown during the computation of a cell's value, it will be propagated to all\npoints where the value is referenced. This allows exceptions to be handled using ",(0,i.jsx)(n.code,{children:"try"})," and ",(0,i.jsx)(n.code,{children:"catch"}),"\ninside computed cells:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Exception handling in computed cells"',children:"final str = MutableCell('0');\nfinal n = ValueCell.computed(() => int.parse(str()));\n\nfinal isValid = ValueCell.computed(() {\n  try {\n    return n() > 0;\n  }\n  catch (e) {\n    return false;\n  }\n});\n\nprint(isValid.value); // Prints false\n\nstr.value = '5';\nprint(isValid.value); // Prints true\n\nstr.value = 'not a number';\nprint(isValid.value); // Prints false\n"})}),"\n",(0,i.jsxs)(n.p,{children:["This library provides two utility methods, ",(0,i.jsx)(n.code,{children:"onError"})," and ",(0,i.jsx)(n.code,{children:"error"}),", for\nhandling exceptions thrown in computed cells."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"onError"})," method creates a cell that selects the value of another\ncell when an exception is thrown. The ",(0,i.jsx)(n.code,{children:"error"})," method creates a cell\nwhich holds the exception thrown or ",(0,i.jsx)(n.code,{children:"null"})," if no exception is thrown."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Example of onError"',children:"final str = MutableCell('0');\nfinal m = MutableCell(2);\nfinal n = ValueCell.computed(() => int.parse(str()));\n\nfinal result = n.onError(m); // Equal to n(). If n() throws, equal to m();\n\nstr.value = '3';\nprint(result.value); // Prints 3\n\nstr.value = 'not a number';\nprint(result.value); // Prints 2\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"onError"})," is a generic method with a type argument which when given, only exceptions of the given\ntype are handled."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Handling specific exceptions with onError"',children:"final result = n.onError<FormatException>(m); // Only handles FormatException\n"})}),"\n",(0,i.jsx)(n.p,{children:"The above validation logic can be implemented more succinctly using:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Putting it all together"',children:"final str = MutableCell('0');\nfinal n = ValueCell.computed(() => int.parse(str()));\nfinal isValid = (n > 0.cell).onError(false.cell);\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["We used ",(0,i.jsx)(n.code,{children:"0.cell"})," and ",(0,i.jsx)(n.code,{children:"false.cell"})," to create constant cells that hold\nthe values ",(0,i.jsx)(n.code,{children:"0"})," and ",(0,i.jsx)(n.code,{children:"false"}),", respectively."]})}),"\n",(0,i.jsx)(n.h2,{id:"previous-values",children:"Previous Values"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"previous"})," property can be used to retrieve the previous values of cells:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Retrieving previous cell values"',children:"final a = MutableCell(0);\nfinal prev = a.previous;\n\nfinal sum = ValueCell.computed(() => a() + prev());\n\na.value = 1;\nprint(a.value);    // Prints 1\nprint(prev.value); // Prints 0\nprint(sum.value);  // Prints 1\n\na.value = 5;\nprint(a.value);    // Prints 5\nprint(prev.value); // Prints 1\nprint(sum.value);  // Prints 6\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"previous"})," property returns a cell, which can be used like any\nother cell. This is also a keyed cell. Keyed cells share a common\nstate identified by a key. This allows you to call the ",(0,i.jsx)(n.code,{children:"previous"}),"\nproperty multiple times and even though a new cell instance is\nreturned every time it is called, every instance created by ",(0,i.jsx)(n.code,{children:"previous"}),"\non the same cell, shares the same state."]})}),"\n",(0,i.jsx)(n.admonition,{type:"caution",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["On creation ",(0,i.jsx)(n.code,{children:"prev"})," does not hold a value. Accessing it will throw an ",(0,i.jsx)(n.code,{children:"UninitializedCellError"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["For ",(0,i.jsx)(n.code,{children:"prev"})," to actually keep track of the previous value of ",(0,i.jsx)(n.code,{children:"a"}),", ",(0,i.jsx)(n.code,{children:"prev"})," must be observed, either\nby another cell, a ",(0,i.jsx)(n.code,{children:"CellWidget"})," or a ",(0,i.jsx)(n.em,{children:"watch function"}),"."]}),"\n"]})}),"\n",(0,i.jsx)(n.h2,{id:"peeking-cells",children:"Peeking Cells"}),"\n",(0,i.jsx)(n.p,{children:"What if you want to use the value of a cell in a computed cell but\ndon't want changes to that cell's value triggering a\nrecomputation. The peek property allows you to do exactly that."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="Example of .peek"',children:"final a = MutableCell(0);\nfinal b = MutableCell(1);\n\nfinal c = ValueCell.computed(() => a() + b.peek());\n\nfinal watch = ValueCell.watch(() => print('${c()}'));\n\na.value = 3; // Prints: 4\nb.value = 5; // Doesn't print anything\na.value = 7; // Prints: 13\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example cell ",(0,i.jsx)(n.code,{children:"c"})," is a computed cell referencing the value\nof ",(0,i.jsx)(n.code,{children:"a"})," and ",(0,i.jsx)(n.em,{children:"peeks"})," the value of ",(0,i.jsx)(n.code,{children:"b"}),". Changing the value of ",(0,i.jsx)(n.code,{children:"a"}),"\ntriggers a recomputation of ",(0,i.jsx)(n.code,{children:"c"}),", and hence triggers the watch function\nwhich prints to the console, but changing the value of ",(0,i.jsx)(n.code,{children:"b"})," doesn't\ntrigger a recomputation of ",(0,i.jsx)(n.code,{children:"c"}),"."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"peek"})," returns a cell."]})}),"\n",(0,i.jsxs)(n.p,{children:["You may be asking why do we need ",(0,i.jsx)(n.code,{children:"peek"})," here instead of just accessing\nthe value of ",(0,i.jsx)(n.code,{children:"b"})," directly ",(0,i.jsx)(n.code,{children:"b.value"}),". Something we've glossed over till\nthis point is the lifecycle of cells. Cells are only active while they\nare actually observed, and are activated when the first observer is\nadded. While active, cells react to changes in their argument\ncells. When the last observer is removed, cells are deactivated and\nstop observing their argument cells. When a new observer is added,\nthey are reactivated again. Essentially, this means that the value of\na cell may no longer be current if it doesn't have at least one\nobserver. For a computed cell this is not a problem, since when it is\ninactive it computes its value on demand, but it may cause issues with\nother cells, such as ",(0,i.jsx)(n.code,{children:"previous"})," cells. The ",(0,i.jsx)(n.code,{children:"peek"})," property takes\ncare of adding an observer to the peeked cell, so that it remains\nactive, but at the same time prevents the observers, added through\n",(0,i.jsx)(n.code,{children:"peek"}),", from being notified of the changes in its value."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,l)=>{l.d(n,{R:()=>a,x:()=>r});var i=l(6540);const t={},s=i.createContext(t);function a(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);